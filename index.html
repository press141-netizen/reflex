<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reflex - Designer's Archive</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">

  <!-- CDN Libraries: Pinned versions for security and stability -->
  <!-- TODO: Add SRI integrity hashes - Generate at https://www.srihash.org/ -->
  <!-- React 18.3.1 (pinned) -->
  <script src="https://unpkg.com/react@18.3.1/umd/react.production.min.js" crossorigin="anonymous"></script>
  <!-- React-DOM 18.3.1 (pinned) -->
  <script src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.production.min.js" crossorigin="anonymous"></script>
  <!-- Babel Standalone 7.26.10 (pinned, fixes CVE-2025-27789) -->
  <script src="https://unpkg.com/@babel/standalone@7.26.10/babel.min.js" crossorigin="anonymous"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Outfit', sans-serif; background: linear-gradient(180deg, #FAFBFC 0%, #F5F7FA 50%, #EEF2F7 100%); min-height: 100vh; }
    @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useMemo, useEffect, useRef, useCallback } = React;

    const TYPES = [
      { id: 'all', name: 'All', emoji: '‚ú¶' },
      { id: 'web', name: 'Web', emoji: '‚óé' },
      { id: 'mobile', name: 'Mobile', emoji: '‚óê' },
      { id: 'graphic', name: 'Graphic', emoji: '‚óà' },
      { id: 'component', name: 'Component', emoji: '‚ó´' },
    ];

    const DEFAULT_CATEGORIES = {
      web: ['Landing', 'Portfolio', 'E-commerce', 'Dashboard', 'Blog', 'Corporate'],
      mobile: ['iOS', 'Android', 'App', 'Onboarding'],
      graphic: ['Poster', 'Banner', 'Icon', 'Illustration', 'Logo', 'Print'],
      component: ['Navigation', 'Hero', 'Button', 'Card', 'Form', 'Modal', 'Sidebar', 'Footer'],
    };

    // ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞: images Î∞∞Ïó¥ (Í∞Å Ïù¥ÎØ∏ÏßÄÎ≥Ñ note, figmaCode, isComponent)
    const DEFAULT_REFERENCES = [
      {
        id: 1,
        type: 'web',
        title: 'Linear Homepage',
        url: 'https://linear.app',
        images: [
          { id: 'img1', src: 'https://images.unsplash.com/photo-1618005182384-a83a8bd57fbe?w=600&h=400&fit=crop', note: 'Î©îÏù∏ ÌûàÏñ¥Î°ú ÏÑπÏÖò', figmaCode: null, isComponent: false },
        ],
        category: 'landing',
        tags: ['minimal', 'dark', 'saas'],
        addedAt: '2024.12.15 AM 10:30',
      },
      {
        id: 2,
        type: 'component',
        title: 'Glass Navigation',
        url: 'https://vercel.com',
        images: [
          { id: 'img2', src: 'https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=600&h=400&fit=crop', note: 'Î∏îÎü¨ Ìö®Í≥º ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò', figmaCode: null, isComponent: false },
        ],
        category: 'navigation',
        tags: ['glassmorphism', 'blur'],
        addedAt: '2024.12.12',
      },
    ];

    function App() {
      // URLÏóêÏÑú ÌåÄ ID Ï∂îÏ∂ú (/t/{teamId} ÌòïÏãù)
      const getTeamId = () => {
        const path = window.location.pathname;
        const match = path.match(/^\/t\/(.+)$/);
        return match ? match[1] : null;
      };
      
      const [teamId, setTeamId] = useState(getTeamId());
      const [references, setReferences] = useState([]);
      const [customCategories, setCustomCategories] = useState({ web: [], mobile: [], graphic: [], component: [] });
      const [isLoading, setIsLoading] = useState(true);
      const [isSaving, setIsSaving] = useState(false);
      
      const [activeType, setActiveType] = useState('all');
      const [activeCategory, setActiveCategory] = useState('all');
      const [searchQuery, setSearchQuery] = useState('');
      const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');
      const [selectedTags, setSelectedTags] = useState([]);
      const [selectedRef, setSelectedRef] = useState(null);
      const [selectedImageIndex, setSelectedImageIndex] = useState(0);
      const [isAddModalOpen, setIsAddModalOpen] = useState(false);
      const [isEditModalOpen, setIsEditModalOpen] = useState(false);
      const [editRef, setEditRef] = useState(null);
      const [imageZoom, setImageZoom] = useState(null);
      const [isGenerating, setIsGenerating] = useState(null);
      const [tagInput, setTagInput] = useState('');
      const [showTagSuggestions, setShowTagSuggestions] = useState(false);
      const [categoryInput, setCategoryInput] = useState('');
      const [showCategorySuggestions, setShowCategorySuggestions] = useState(false);
      const tagInputRef = useRef(null);
      const categoryInputRef = useRef(null);
      
      // ÌòÑÏû¨ Î≥¥Îìú ID (ÌåÄÏù¥Î©¥ ÌåÄID, ÏïÑÎãàÎ©¥ public)
      const currentBoardId = teamId || 'public';
      
      // Î™®Îã¨ Îã´Í∏∞ - mousedownÍ≥º mouseupÏù¥ Í∞ôÏùÄ overlayÏóêÏÑú Î∞úÏÉùÌñàÏùÑ ÎïåÎßå Îã´Í∏∞
      const mouseDownTarget = useRef(null);
      const handleOverlayMouseDown = (e) => {
        mouseDownTarget.current = e.target;
      };
      const handleOverlayClick = (e, closeFunc) => {
        // mousedownÍ≥º clickÏù¥ Î™®Îëê overlay ÏûêÏ≤¥ÏóêÏÑú Î∞úÏÉùÌñàÏùÑ ÎïåÎßå Îã´Í∏∞
        if (e.target === e.currentTarget && mouseDownTarget.current === e.currentTarget) {
          closeFunc();
        }
        mouseDownTarget.current = null;
      };
      
      // ÎìúÎ°≠Îã§Ïö¥ Îã´Í∏∞ - blur Ïù¥Î≤§Ìä∏ ÏÇ¨Ïö© (Î™®Îã¨Í≥º Ï∂©Îèå Î∞©ÏßÄ)
      const handleTagInputBlur = (e) => {
        setTimeout(() => {
          if (!tagInputRef.current?.contains(document.activeElement)) {
            setShowTagSuggestions(false);
          }
        }, 150);
      };
      
      const handleCategoryInputBlur = (e) => {
        setTimeout(() => {
          if (!categoryInputRef.current?.contains(document.activeElement)) {
            setShowCategorySuggestions(false);
          }
        }, 150);
      };
      
      const [newRef, setNewRef] = useState({
        type: 'web',
        title: '',
        url: '',
        images: [],
        category: 'Landing',
        tags: [],
        colors: [],
        hexColor: '',
        visibility: 'public',
        targetTeamId: '',
      });

      // Ïª¨Îü¨ ÏòµÏÖò
      const COLOR_OPTIONS = [
        { id: 'red', color: '#ef4444' },
        { id: 'orange', color: '#f97316' },
        { id: 'yellow', color: '#eab308' },
        { id: 'green', color: '#22c55e' },
        { id: 'blue', color: '#3b82f6' },
        { id: 'purple', color: '#8b5cf6' },
        { id: 'pink', color: '#ec4899' },
        { id: 'gray', color: '#6b7280' },
        { id: 'black', color: '#1f2937' },
        { id: 'white', color: '#f9fafb' },
      ];

      // ÏÑúÎ≤ÑÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎìú
      useEffect(() => {
        const loadData = async () => {
          try {
            const res = await fetch(`/api/boards?boardId=${currentBoardId}`);
            const data = await res.json();
            setReferences(data.references || []);
            if (data.customCategories) {
              setCustomCategories(data.customCategories);
            }
          } catch (error) {
            console.error('Failed to load:', error);
          } finally {
            setIsLoading(false);
          }
        };
        loadData();
      }, [currentBoardId]);

      // Í≤ÄÏÉâÏñ¥ ÎîîÎ∞îÏö¥Ïã± (300ms)
      useEffect(() => {
        const timer = setTimeout(() => {
          setDebouncedSearchQuery(searchQuery);
        }, 300);

        return () => clearTimeout(timer);
      }, [searchQuery]);

      // Î≤†Ïù¥Ïä§ ÌïÑÌÑ∞ÎßÅ (ÌÉÄÏûÖ, Ïπ¥ÌÖåÍ≥†Î¶¨, Í≤ÄÏÉâÏñ¥) - Ï°∞Í∏∞ Î∞òÌôòÏúºÎ°ú ÏµúÏ†ÅÌôî
      const baseFilteredReferences = useMemo(() => {
        return references.filter(ref => {
          if (activeType !== 'all' && ref.type !== activeType) return false;
          if (activeCategory !== 'all' && ref.category !== activeCategory) return false;
          if (debouncedSearchQuery) {
            const q = debouncedSearchQuery.toLowerCase();
            // Ï°∞Í∏∞ Î∞òÌôò: ÌïòÎÇòÎùºÎèÑ Îß§ÏπòÎêòÎ©¥ Ï¶âÏãú true Î∞òÌôò
            if (ref.title.toLowerCase().includes(q)) return true;
            if (ref.tags?.some(t => t.toLowerCase().includes(q))) return true;
            if (ref.images?.some(img => img.note?.toLowerCase().includes(q))) return true;
            return false;
          }
          return true;
        });
      }, [references, activeType, activeCategory, debouncedSearchQuery]);

      // Ï†ÑÏ≤¥ ÌÉúÍ∑∏ Î™©Î°ù (Î≤†Ïù¥Ïä§ ÌïÑÌÑ∞ÎßÅ Í≤∞Í≥º Ïû¨ÏÇ¨Ïö©)
      const visibleTags = useMemo(() => {
        const tags = new Set();
        baseFilteredReferences.forEach(ref => ref.tags?.forEach(tag => tags.add(tag)));
        return Array.from(tags).sort();
      }, [baseFilteredReferences]);

      // Ï†ÑÏ≤¥ ÌÉúÍ∑∏ Î™©Î°ù (ÌÉúÍ∑∏ ÏûÖÎ†• ÏûêÎèôÏôÑÏÑ±Ïö©)
      const allTags = useMemo(() => {
        const tags = new Set();
        references.forEach(ref => ref.tags?.forEach(tag => tags.add(tag)));
        return Array.from(tags).sort();
      }, [references]);

      // Ïª§Ïä§ÌÖÄ Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑúÎ≤ÑÏóê Ï†ÄÏû•
      const saveCustomCategories = async (newCategories) => {
        try {
          await fetch('/api/categories', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ customCategories: newCategories }),
          });
        } catch (err) {
          console.error('Failed to save categories:', err);
        }
      };

      // Ï†ÑÏ≤¥ Ïπ¥ÌÖåÍ≥†Î¶¨ (Í∏∞Î≥∏ + Ïª§Ïä§ÌÖÄ)
      const allCategories = useMemo(() => {
        const result = {};
        Object.keys(DEFAULT_CATEGORIES).forEach(type => {
          result[type] = [...DEFAULT_CATEGORIES[type], ...(customCategories[type] || [])];
        });
        return result;
      }, [customCategories]);

      // ÏµúÏ¢Ö ÌïÑÌÑ∞ÎßÅ (Î≤†Ïù¥Ïä§ ÌïÑÌÑ∞ÎßÅ + ÌÉúÍ∑∏ ÌïÑÌÑ∞)
      const filteredReferences = useMemo(() => {
        if (selectedTags.length === 0) return baseFilteredReferences;
        return baseFilteredReferences.filter(ref =>
          selectedTags.every(t => ref.tags?.includes(t))
        );
      }, [baseFilteredReferences, selectedTags]);

      // Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨ Ìï®Ïàò (ÌååÏùº Î∞∞Ïó¥ Î∞õÏùå) - Î∞∞Ïπò Ï≤òÎ¶¨Î°ú ÏµúÏ†ÅÌôî
      const processImageFiles = (files, isEdit = false) => {
        const imageFiles = Array.from(files).filter(file => file.type?.startsWith('image/'));
        if (imageFiles.length === 0) return;

        const processedImages = [];
        let loadedCount = 0;

        imageFiles.forEach((file, index) => {
          const reader = new FileReader();
          reader.onload = (ev) => {
            const img = new Image();
            img.onload = () => {
              processedImages[index] = {
                id: crypto.randomUUID(),
                src: ev.target.result,
                note: '',
                figmaCode: null,
                isComponent: false,
                width: img.naturalWidth,
                height: img.naturalHeight,
              };
              loadedCount++;

              // Î™®Îì† Ïù¥ÎØ∏ÏßÄÍ∞Ä Î°úÎìúÎêòÎ©¥ Ìïú Î≤àÏóê ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
              if (loadedCount === imageFiles.length) {
                const validImages = processedImages.filter(Boolean);
                if (isEdit && editRef) {
                  setEditRef(prev => ({ ...prev, images: [...prev.images, ...validImages] }));
                } else {
                  setNewRef(prev => ({ ...prev, images: [...prev.images, ...validImages] }));
                }
              }
            };
            img.src = ev.target.result;
          };
          reader.readAsDataURL(file);
        });
      };

      // Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ìï∏Îì§Îü¨ (input file)
      const handleImageUpload = (e, isEdit = false) => {
        const files = Array.from(e.target.files || []);
        processImageFiles(files, isEdit);
      };

      // ÎìúÎûòÍ∑∏Ïï§ÎìúÎ°≠ ÏÉÅÌÉú
      const [isDragging, setIsDragging] = useState(false);
      
      const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
      };
      
      const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
      };
      
      const handleDrop = (e, isEdit = false) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
        const files = Array.from(e.dataTransfer.files);
        if (files.length > 0) {
          processImageFiles(files, isEdit);
        }
      };

      // ÌÅ¥Î¶ΩÎ≥¥Îìú Î∂ôÏó¨ÎÑ£Í∏∞ Ìï∏Îì§Îü¨
      const handlePaste = (e, isEdit = false) => {
        const items = e.clipboardData?.items;
        if (!items) return;
        
        for (const item of items) {
          if (item.type.startsWith('image/')) {
            e.preventDefault();
            const file = item.getAsFile();
            if (file) {
              processImageFiles([file], isEdit);
            }
          }
        }
      };

      // Ïù¥ÎØ∏ÏßÄ ÏÇ≠Ï†ú
      const handleRemoveImage = (imgId, isEdit = false) => {
        if (isEdit) {
          setEditRef(prev => ({ ...prev, images: prev.images.filter(img => img.id !== imgId) }));
        } else {
          setNewRef(prev => ({ ...prev, images: prev.images.filter(img => img.id !== imgId) }));
        }
      };

      // Ïù¥ÎØ∏ÏßÄ ÎÖ∏Ìä∏ ÏàòÏ†ï
      const handleImageNoteChange = (imgId, note, isEdit = false) => {
        if (isEdit) {
          setEditRef(prev => ({
            ...prev,
            images: prev.images.map(img => img.id === imgId ? { ...img, note } : img)
          }));
        } else {
          setNewRef(prev => ({
            ...prev,
            images: prev.images.map(img => img.id === imgId ? { ...img, note } : img)
          }));
        }
      };

      // ÌÉúÍ∑∏ Ï∂îÍ∞Ä
      const handleAddTag = (tag, isEdit = false) => {
        const trimmed = tag.trim().toLowerCase();
        if (!trimmed) return;
        if (isEdit) {
          if (!editRef.tags.includes(trimmed)) {
            setEditRef(prev => ({ ...prev, tags: [...prev.tags, trimmed] }));
          }
        } else {
          if (!newRef.tags.includes(trimmed)) {
            setNewRef(prev => ({ ...prev, tags: [...prev.tags, trimmed] }));
          }
        }
        setTagInput('');
        setShowTagSuggestions(false);
      };

      // ÌÉúÍ∑∏ Ï†úÍ±∞
      const handleRemoveTag = (tag, isEdit = false) => {
        if (isEdit) {
          setEditRef(prev => ({ ...prev, tags: prev.tags.filter(t => t !== tag) }));
        } else {
          setNewRef(prev => ({ ...prev, tags: prev.tags.filter(t => t !== tag) }));
        }
      };

      // ÌÉúÍ∑∏ Ï†úÏïà ÌïÑÌÑ∞
      const filteredTagSuggestions = useMemo(() => {
        if (!tagInput) return allTags.slice(0, 10);
        return allTags.filter(t => t.includes(tagInput.toLowerCase())).slice(0, 10);
      }, [tagInput, allTags]);

      // Ïπ¥ÌÖåÍ≥†Î¶¨ Ï∂îÍ∞Ä
      const handleAddCategory = (type, category) => {
        const trimmed = category.trim();
        if (!trimmed) return;
        if (!allCategories[type]?.includes(trimmed)) {
          const newCategories = {
            ...customCategories,
            [type]: [...(customCategories[type] || []), trimmed]
          };
          setCustomCategories(newCategories);
          saveCustomCategories(newCategories);
        }
        setCategoryInput('');
        setShowCategorySuggestions(false);
      };

      // ÎÇ†Ïßú Ìè¨Îß∑ Ìï®Ïàò
      const formatDateTime = () => {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = now.getHours();
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const ampm = hours >= 12 ? 'PM' : 'AM';
        const hour12 = String(hours % 12 || 12).padStart(2, '0');
        return `${year}.${month}.${day} ${ampm} ${hour12}:${minutes}`;
      };

      // Ïù¥ÎØ∏ÏßÄ Ïª¥Ìè¨ÎÑåÌä∏ Ï≤¥ÌÅ¨ ÌÜ†Í∏Ä
      const handleToggleComponent = (imgId, isEdit = false) => {
        if (isEdit) {
          setEditRef(prev => ({
            ...prev,
            images: prev.images.map(img => 
              img.id === imgId ? { ...img, isComponent: !img.isComponent } : img
            )
          }));
        } else {
          setNewRef(prev => ({
            ...prev,
            images: prev.images.map(img => 
              img.id === imgId ? { ...img, isComponent: !img.isComponent } : img
            )
          }));
        }
      };

      // Ïù¥ÎØ∏ÏßÄÎ•º BlobÏóê ÏóÖÎ°úÎìúÌïòÎäî Ìï®Ïàò
      const uploadImageToBlob = async (base64Image) => {
        try {
          const res = await fetch('/api/upload', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              image: base64Image,
              contentType: base64Image.match(/^data:(image\/\w+);/)?.[1] || 'image/png',
            }),
          });
          const data = await res.json();
          return data.url || base64Image; // Ïã§Ìå®Ïãú ÏõêÎ≥∏ Î∞òÌôò
        } catch (error) {
          console.error('Upload failed:', error);
          return base64Image;
        }
      };

      // Î†àÌçºÎü∞Ïä§ Ï∂îÍ∞Ä (Ïª¥Ìè¨ÎÑåÌä∏ ÏûêÎèô ÏÉùÏÑ± Ìè¨Ìï®)
      const handleAddReference = async () => {
        if (!newRef.title || newRef.images.length === 0) {
          alert('Ï†úÎ™©Í≥º ÏµúÏÜå 1Í∞úÏùò Ïù¥ÎØ∏ÏßÄÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.');
          return;
        }
        
        // ÌåÄ Î≥¥Îìú ÏÑ†ÌÉùÌñàÎäîÎç∞ ID ÏóÜÏúºÎ©¥ ÏóêÎü¨
        if (newRef.visibility === 'team' && !newRef.targetTeamId) {
          alert('ÌåÄ Î≥¥Îìú IDÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
          return;
        }
        
        setIsSaving(true);
        
        try {
          // Ïù¥ÎØ∏ÏßÄÎì§ÏùÑ BlobÏóê ÏóÖÎ°úÎìú
          const uploadedImages = await Promise.all(
            newRef.images.map(async (img) => {
              if (img.src.startsWith('data:')) {
                const blobUrl = await uploadImageToBlob(img.src);
                return { ...img, src: blobUrl };
              }
              return img;
            })
          );
          
          const addedAt = formatDateTime();
          
          // visibilityÏóê Îî∞Îùº Ï†ÄÏû•Ìï† Î≥¥Îìú Í≤∞Ï†ï
          const targetBoardId = newRef.visibility === 'team' ? newRef.targetTeamId : 'public';
          
          const reference = {
            ...newRef,
            images: uploadedImages,
            addedAt,
            boardId: targetBoardId,
            targetTeamId: undefined, // ÏûÑÏãú ÌïÑÎìú Ï†úÍ±∞
          };
          delete reference.targetTeamId;
          
          // ÏÑúÎ≤ÑÏóê Ï†ÄÏû•
          const res = await fetch(`/api/boards?boardId=${targetBoardId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ reference }),
          });
          
          const data = await res.json();
          if (data.success) {
            // ÌòÑÏû¨ Î≥¥ÎìúÏóê Ï†ÄÏû•Îêú Í≤ΩÏö∞Îßå Î™©Î°ùÏóê Ï∂îÍ∞Ä
            if (targetBoardId === currentBoardId) {
              setReferences(prev => [data.reference, ...prev]);
            } else {
              alert(`${newRef.visibility === 'public' ? 'Í≥µÏö©' : 'ÌåÄ'} Î≥¥ÎìúÏóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.`);
            }
            
            // Ïª¥Ìè¨ÎÑåÌä∏Î°ú Ï≤¥ÌÅ¨Îêú Ïù¥ÎØ∏ÏßÄÎì§ ÏûêÎèô Ï∂îÍ∞Ä (Î≥ëÎ†¨ Ï≤òÎ¶¨)
            const componentImages = uploadedImages.filter(img => img.isComponent);
            if (componentImages.length > 0) {
              const componentPromises = componentImages.map(img => {
                const componentRef = {
                  type: 'component',
                  title: `${newRef.title} - Component`,
                  url: newRef.url,
                  images: [{ ...img, isComponent: false }],
                  category: 'card',
                  tags: [...newRef.tags],
                  visibility: newRef.visibility,
                  boardId: targetBoardId,
                };

                return fetch(`/api/boards?boardId=${targetBoardId}`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ reference: componentRef }),
                }).then(res => res.json());
              });

              const componentResults = await Promise.all(componentPromises);

              // ÌòÑÏû¨ Î≥¥ÎìúÏóê Ï∂îÍ∞ÄÎêú Ïª¥Ìè¨ÎÑåÌä∏Îßå Î™©Î°ùÏóê Î∞òÏòÅ
              if (targetBoardId === currentBoardId) {
                const newComponents = componentResults
                  .filter(data => data.success)
                  .map(data => data.reference);
                if (newComponents.length > 0) {
                  setReferences(prev => [...newComponents, ...prev]);
                }
              }
            }
          }
          
          setIsAddModalOpen(false);
          setNewRef({ type: 'web', title: '', url: '', images: [], category: 'landing', tags: [], colors: [], hexColor: '', visibility: 'public', targetTeamId: '' });
        } catch (error) {
          console.error('Failed to add reference:', error);
          alert('Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
        } finally {
          setIsSaving(false);
        }
      };

      // Î†àÌçºÎü∞Ïä§ ÏàòÏ†ï Ï†ÄÏû•
      const handleSaveEdit = async () => {
        if (!editRef.title) return;
        
        // ÌåÄ Î≥¥Îìú ÏÑ†ÌÉùÌñàÎäîÎç∞ ID ÏóÜÏúºÎ©¥ ÏóêÎü¨
        if (editRef.visibility === 'team' && !editRef.targetTeamId) {
          alert('ÌåÄ Î≥¥Îìú IDÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
          return;
        }
        
        setIsSaving(true);
        try {
          // ÏÉà Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏûàÏúºÎ©¥ ÏóÖÎ°úÎìú
          const uploadedImages = await Promise.all(
            editRef.images.map(async (img) => {
              if (img.src.startsWith('data:')) {
                const blobUrl = await uploadImageToBlob(img.src);
                return { ...img, src: blobUrl };
              }
              return img;
            })
          );
          
          // Í∏∞Ï°¥ Î≥¥Îìú ID (ÏóÜÏúºÎ©¥ ÌòÑÏû¨ Î≥¥Îìú)
          const oldBoardId = editRef.boardId || currentBoardId;
          // ÏÉà Î≥¥Îìú ID
          const newBoardId = editRef.visibility === 'team' ? editRef.targetTeamId : 'public';
          
          const updatedRef = { 
            ...editRef, 
            images: uploadedImages, 
            boardId: newBoardId,
            targetTeamId: undefined, // ÏûÑÏãú ÌïÑÎìú Ï†úÍ±∞
          };
          delete updatedRef.targetTeamId;
          
          // Î≥¥ÎìúÍ∞Ä Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞
          if (oldBoardId !== newBoardId) {
            // Í∏∞Ï°¥ Î≥¥ÎìúÏóêÏÑú ÏÇ≠Ï†ú
            await fetch(`/api/boards?boardId=${oldBoardId}`, {
              method: 'DELETE',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ referenceId: editRef.id }),
            });
            
            // ÏÉà Î≥¥ÎìúÏóê Ï∂îÍ∞Ä
            const res = await fetch(`/api/boards?boardId=${newBoardId}`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ reference: updatedRef }),
            });
            
            const data = await res.json();
            if (data.success) {
              // ÌòÑÏû¨ Î≥¥ÎìúÏóêÏÑúÎäî ÏÇ≠Ï†ú
              setReferences(prev => prev.filter(ref => ref.id !== editRef.id));
              alert(`${editRef.visibility === 'public' ? 'Í≥µÏö©' : 'ÌåÄ'} Î≥¥ÎìúÎ°ú Ïù¥ÎèôÎêòÏóàÏäµÎãàÎã§.`);
            }
          } else {
            // Í∞ôÏùÄ Î≥¥Îìú ÎÇ¥ ÏàòÏ†ï
            const res = await fetch(`/api/boards?boardId=${newBoardId}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ reference: updatedRef }),
            });
          
            if (res.ok) {
              setReferences(prev => prev.map(ref => ref.id === editRef.id ? updatedRef : ref));
              setSelectedRef(updatedRef);
            }
          }
        } catch (error) {
          console.error('Failed to save:', error);
        } finally {
          setIsSaving(false);
          setIsEditModalOpen(false);
        }
      };

      // Î†àÌçºÎü∞Ïä§ ÏÇ≠Ï†ú
      const handleDeleteReference = useCallback(async (id) => {
        if (!confirm('Ï†ïÎßê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) return;

        const ref = references.find(r => r.id === id);
        const boardId = ref?.boardId || currentBoardId;

        try {
          await fetch(`/api/boards?boardId=${boardId}`, {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ referenceId: id }),
          });

          setReferences(prev => prev.filter(ref => ref.id !== id));
          setSelectedRef(null);
        } catch (error) {
          console.error('Failed to delete:', error);
        }
      }, [references, currentBoardId]);

      // Figma ÏΩîÎìú ÏÉùÏÑ± (ÌäπÏ†ï Ïù¥ÎØ∏ÏßÄ)
      const handleGenerateFigma = async (refId, imgId) => {
        const ref = references.find(r => r.id === refId);
        const img = ref?.images.find(i => i.id === imgId);
        if (!img) return;

        setIsGenerating(imgId);
        
        try {
          let base64Data = img.src;
          let mimeType = 'image/png';
          
          if (img.src.startsWith('data:')) {
            const [header, data] = img.src.split(',');
            mimeType = header.match(/data:(.*?);/)?.[1] || 'image/png';
            base64Data = data;
          } else {
            // URLÏù∏ Í≤ΩÏö∞ fetch
            const response = await fetch(img.src);
            const blob = await response.blob();
            mimeType = blob.type;
            base64Data = await new Promise(resolve => {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result.split(',')[1]);
              reader.readAsDataURL(blob);
            });
          }

          // Ïù¥ÎØ∏ÏßÄ ÌÅ¨Í∏∞
          const imgEl = new Image();
          imgEl.src = img.src;
          await new Promise(resolve => { imgEl.onload = resolve; });

          const apiResponse = await fetch('/api/analyze', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              image: base64Data,
              mimeType,
              componentName: ref.title,
              imageWidth: img.width || imgEl.naturalWidth,
              imageHeight: img.height || imgEl.naturalHeight,
              // AI Î∂ÑÏÑù Ï†ïÎ∞ÄÎèÑ Ìñ•ÏÉÅÏùÑ ÏúÑÌïú Ïª®ÌÖçÏä§Ìä∏ Ï†ïÎ≥¥
              context: {
                note: img.note || '',
                tags: ref.tags || [],
                type: ref.type,
                category: ref.category,
              },
            }),
          });

          if (!apiResponse.ok) throw new Error('API failed');
          
          const result = await apiResponse.json();

          if (result.figmaCode) {
            // ÏµúÏ†ÅÌôî: O(n√óm) ‚Üí O(n) - ÌäπÏ†ï Î†àÌçºÎü∞Ïä§ÏôÄ Ïù¥ÎØ∏ÏßÄÎßå ÏóÖÎç∞Ïù¥Ìä∏
            const updatedRef = {
              ...ref,
              images: ref.images.map(i => i.id === imgId ? { ...i, figmaCode: result.figmaCode } : i)
            };

            setReferences(prev => prev.map(r => r.id === refId ? updatedRef : r));

            // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ref ÏóÖÎç∞Ïù¥Ìä∏
            if (selectedRef?.id === refId) {
              setSelectedRef(updatedRef);
            }

            // ÏÑúÎ≤ÑÏóêÎèÑ Ï†ÄÏû•
            fetch(`/api/boards`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ reference: updatedRef }),
            }).catch(err => console.error('Failed to save figma code:', err));
          }
        } catch (error) {
          console.error('Figma ÏÉùÏÑ± Ïã§Ìå®:', error);
          alert('Figma ÏΩîÎìú ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
        } finally {
          setIsGenerating(null);
        }
      };

      // ÌÅ¥Î¶ΩÎ≥¥Îìú Î≥µÏÇ¨ (ÌîºÎìúÎ∞± Ìè¨Ìï®)
      const [copySuccess, setCopySuccess] = useState(false);
      const copyToClipboard = useCallback((code) => {
        navigator.clipboard.writeText(code);
        setCopySuccess(true);
        setTimeout(() => setCopySuccess(false), 2000);
      }, []);

      // ÌÉúÍ∑∏ ÌÜ†Í∏Ä (Îã§Ï§ë ÏÑ†ÌÉù)
      const toggleTag = useCallback((tag) => {
        setSelectedTags(prev =>
          prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag]
        );
      }, []);

      // ÌåÄ Î≥¥Îìú ÏÉùÏÑ±
      const createTeamBoard = useCallback(() => {
        const newTeamId = crypto.randomUUID();
        const teamUrl = `${window.location.origin}/t/${newTeamId}`;
        navigator.clipboard.writeText(teamUrl);
        alert(`ÌåÄ Î≥¥ÎìúÍ∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§!\n\nÎßÅÌÅ¨Í∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§:\n${teamUrl}\n\nÏù¥ ÎßÅÌÅ¨Î•º ÌåÄÏõêÎì§ÏóêÍ≤å Í≥µÏú†ÌïòÏÑ∏Ïöî.`);
        window.location.href = `/t/${newTeamId}`;
      }, []);

      // ÌòÑÏû¨ Î≥¥Îìú ÎßÅÌÅ¨ Î≥µÏÇ¨
      const copyBoardLink = useCallback(() => {
        const url = teamId
          ? `${window.location.origin}/t/${teamId}`
          : window.location.origin;
        navigator.clipboard.writeText(url);
        alert('Î≥¥Îìú ÎßÅÌÅ¨Í∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!');
      }, [teamId]);

      // Î°úÎî© ÌôîÎ©¥
      if (isLoading) {
        return (
          <div style={{...styles.container, display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: '100vh'}}>
            <div style={{textAlign: 'center'}}>
              <div style={{fontSize: '48px', marginBottom: '16px'}}>‚óà</div>
              <div style={{color: '#666'}}>Loading...</div>
            </div>
          </div>
        );
      }

      return (
        <div style={styles.container}>
          {/* Header */}
          <header style={styles.header}>
            <div style={styles.headerInner}>
              <div style={styles.logo}>
                <span style={styles.logoIcon}>‚óà</span>
                <span style={styles.logoText}>Reflex</span>
                {teamId && (
                  <span style={styles.teamBadge}>üë• ÌåÄ Î≥¥Îìú</span>
                )}
              </div>
              <div style={styles.headerActions}>
                {teamId ? (
                  <>
                    <button style={styles.headerBtn} onClick={copyBoardLink} title="ÌåÄ ÎßÅÌÅ¨ Î≥µÏÇ¨">
                      üîó ÎßÅÌÅ¨ Î≥µÏÇ¨
                    </button>
                    <button style={styles.headerBtn} onClick={() => window.location.href = '/'} title="Í≥µÏö© Î≥¥ÎìúÎ°ú">
                      üåê Í≥µÏö© Î≥¥Îìú
                    </button>
                  </>
                ) : (
                  <button style={styles.headerBtn} onClick={createTeamBoard} title="ÌåÄ Î≥¥Îìú ÏÉùÏÑ±">
                    üë• ÌåÄ Î≥¥Îìú ÏÉùÏÑ±
                  </button>
                )}
                <button style={styles.addButton} onClick={() => { setNewRef(prev => ({...prev, visibility: teamId ? 'team' : 'public'})); setIsAddModalOpen(true); }} disabled={isSaving}>
                  {isSaving ? 'Saving...' : '+ Add Reference'}
                </button>
              </div>
            </div>
          </header>

          {/* Filters */}
          <section style={styles.filterSection}>
            <div style={styles.typeToggle}>
              {TYPES.map(type => (
                <button
                  key={type.id}
                  onClick={() => { setActiveType(type.id); setActiveCategory('all'); setSelectedTags([]); }}
                  style={{ ...styles.typeButton, ...(activeType === type.id ? styles.typeButtonActive : {}) }}
                >
                  {type.emoji} {type.name}
                </button>
              ))}
            </div>
            <div style={styles.searchWrapper}>
              <span style={styles.searchIcon}>üîç</span>
              <input
                type="text"
                placeholder="Search by title, tags, or description..."
                value={searchQuery}
                onChange={e => setSearchQuery(e.target.value)}
                style={styles.searchInput}
              />
              {searchQuery && (
                <button style={styles.searchClear} onClick={() => setSearchQuery('')}>‚úï</button>
              )}
            </div>
          </section>

          {/* Category Filter */}
          {activeType !== 'all' && (
            <div style={styles.categoryFilterSection}>
              <span style={styles.filterLabel}>Category</span>
              <div style={styles.categoryFilter}>
                <button
                  onClick={() => { setActiveCategory('all'); setSelectedTags([]); }}
                  style={{ ...styles.catButton, ...(activeCategory === 'all' ? styles.catButtonActive : {}) }}
                >
                  All
                </button>
                {allCategories[activeType]?.map(cat => (
                  <button
                    key={cat}
                    onClick={() => { setActiveCategory(cat); setSelectedTags([]); }}
                    style={{ ...styles.catButton, ...(activeCategory === cat ? styles.catButtonActive : {}) }}
                  >
                    {cat}
                  </button>
                ))}
              </div>
            </div>
          )}

          {/* Tag Filter - ÌòÑÏû¨ ÌÉÄÏûÖ/Ïπ¥ÌÖåÍ≥†Î¶¨Ïóê Ìï¥ÎãπÌïòÎäî ÌÉúÍ∑∏Îßå ÌëúÏãú */}
          {visibleTags.length > 0 && (
            <div style={styles.tagFilterSection}>
              <span style={styles.filterLabel}>Tags</span>
              <div style={styles.tagFilterList}>
                {visibleTags.slice(0, 15).map(tag => (
                  <button
                    key={tag}
                    onClick={() => toggleTag(tag)}
                    style={{ 
                      ...styles.tagFilterBtn, 
                      ...(selectedTags.includes(tag) ? styles.tagFilterBtnActive : {}) 
                    }}
                  >
                    {tag}
                  </button>
                ))}
                {selectedTags.length > 0 && (
                  <button style={styles.clearTagsBtn} onClick={() => setSelectedTags([])}>
                    Clear
                  </button>
                )}
              </div>
            </div>
          )}

          {/* Grid */}
          <main style={styles.grid}>
            {filteredReferences.map(ref => (
              <article key={ref.id} style={styles.card} onClick={() => { setSelectedRef(ref); setSelectedImageIndex(0); }}>
                <div style={styles.cardImageWrapper}>
                  <img src={ref.images[0]?.src} alt={ref.title} style={styles.cardImage} />
                  {ref.images.length > 1 && (
                    <span style={styles.imageCount}>+{ref.images.length - 1}</span>
                  )}
                  {ref.images.some(img => img.figmaCode) && (
                    <span style={styles.figmaBadge}>‚ó´</span>
                  )}
                </div>
                <div style={styles.cardContent}>
                  <h3 style={styles.cardTitle}>{ref.title}</h3>
                  <div style={styles.cardTags}>
                    {ref.tags?.slice(0, 3).map(tag => (
                      <span key={tag} style={styles.cardTag}>{tag}</span>
                    ))}
                  </div>
                </div>
              </article>
            ))}
          </main>

          {/* Detail Modal */}
          {selectedRef && (
            <div 
              style={styles.modalOverlay} 
              onMouseDown={handleOverlayMouseDown}
              onClick={e => handleOverlayClick(e, () => setSelectedRef(null))}
            >
              <div style={styles.modal}>
                <button style={styles.modalClose} onClick={() => setSelectedRef(null)}>‚úï</button>
                
                {/* Ïù¥ÎØ∏ÏßÄ Í∞§Îü¨Î¶¨ */}
                <div style={styles.imageGallery}>
                  <img
                    src={selectedRef.images[selectedImageIndex]?.src}
                    alt=""
                    style={styles.modalImage}
                    onClick={() => setImageZoom(selectedRef.images[selectedImageIndex]?.src)}
                  />
                  {selectedRef.images.length > 1 && (
                    <div style={styles.imageThumbs}>
                      {selectedRef.images.map((img, idx) => (
                        <img
                          key={img.id}
                          src={img.src}
                          alt=""
                          style={{ ...styles.thumbImg, ...(idx === selectedImageIndex ? styles.thumbImgActive : {}) }}
                          onClick={() => setSelectedImageIndex(idx)}
                        />
                      ))}
                    </div>
                  )}
                </div>

                <div style={styles.modalContent}>
                  <div style={styles.modalMeta}>
                    <span style={styles.modalType}>{TYPES.find(t => t.id === selectedRef.type)?.emoji} {selectedRef.type}</span>
                    <span>‚Ä¢</span>
                    <span>{selectedRef.category}</span>
                  </div>
                  <h2 style={styles.modalTitle}>{selectedRef.title}</h2>
                  {selectedRef.url && (
                    <a href={selectedRef.url} target="_blank" style={styles.modalUrl}>{selectedRef.url} ‚Üó</a>
                  )}
                  
                  {/* ÌòÑÏû¨ Ïù¥ÎØ∏ÏßÄ ÎÖ∏Ìä∏ */}
                  {selectedRef.images[selectedImageIndex]?.note && (
                    <p style={styles.modalNote}>{selectedRef.images[selectedImageIndex].note}</p>
                  )}

                  {/* ÌÉúÍ∑∏ + Ïª¨Îü¨ (Í∞ôÏùÄ Ï§Ñ) */}
                  <div style={styles.tagsColorRow}>
                    {/* ÌÉúÍ∑∏ */}
                    <div style={styles.modalTags}>
                      {selectedRef.tags?.map(tag => (
                        <span key={tag} style={styles.modalTag}>{tag}</span>
                      ))}
                    </div>
                    
                    {/* Ïª¨Îü¨ */}
                    {(selectedRef.colors?.length > 0 || selectedRef.hexColor) && (
                      <div style={styles.modalColors}>
                        <span style={styles.colorLabel}>Colors:</span>
                        {selectedRef.colors?.map(colorId => {
                          const colorObj = COLOR_OPTIONS.find(c => c.id === colorId);
                          return colorObj ? (
                            <span key={colorId} style={{...styles.colorDot, backgroundColor: colorObj.color}} title={colorId}></span>
                          ) : null;
                        })}
                        {selectedRef.hexColor && /^#[0-9A-Fa-f]{6}$/.test(selectedRef.hexColor) && (
                          <span style={{...styles.colorDot, backgroundColor: selectedRef.hexColor}} title={selectedRef.hexColor}></span>
                        )}
                      </div>
                    )}
                  </div>

                  {/* Figma ÏΩîÎìú ÏÉùÏÑ±/ÌëúÏãú - Graphic ÌÉÄÏûÖ Ï†úÏô∏ */}
                  {selectedRef.type !== 'graphic' && (
                    <div style={styles.figmaSection}>
                      {selectedRef.images[selectedImageIndex]?.figmaCode ? (
                        <>
                          <div style={styles.figmaHeader}>
                            <span>ü§ñ AI Figma Code</span>
                            <button
                              style={{ ...styles.copyBtn, ...(copySuccess ? styles.copyBtnSuccess : {}) }}
                              onClick={() => copyToClipboard(selectedRef.images[selectedImageIndex].figmaCode)}
                            >
                              {copySuccess ? '‚úì Copied!' : 'Copy'}
                            </button>
                          </div>
                          <pre style={styles.figmaCode}>
                            {selectedRef.images[selectedImageIndex].figmaCode}
                          </pre>
                          <p style={styles.figmaHint}>Figma ‚Üí Plugins ‚Üí Development ‚Üí Open Console ‚Üí Î∂ôÏó¨ÎÑ£Í∏∞ ÌõÑ Ïã§Ìñâ</p>
                        </>
                      ) : (
                        <button
                          style={{ ...styles.generateBtn, ...(isGenerating ? styles.generateBtnDisabled : {}) }}
                          onClick={() => handleGenerateFigma(selectedRef.id, selectedRef.images[selectedImageIndex].id)}
                          disabled={isGenerating}
                        >
                          {isGenerating === selectedRef.images[selectedImageIndex]?.id ? (
                            <><span style={styles.spinner}></span> AI Î∂ÑÏÑù Ï§ë...</>
                          ) : (
                            'ü§ñ AIÎ°ú Figma Code ÏÉùÏÑ±'
                          )}
                        </button>
                      )}
                    </div>
                  )}

                  <div style={styles.modalFooter}>
                    <span>{selectedRef.addedAt}</span>
                    <div style={styles.modalActions}>
                      <button style={styles.editBtn} onClick={() => { setEditRef({...selectedRef}); setIsEditModalOpen(true); }}>
                        ‚úé Edit
                      </button>
                      <button style={styles.deleteBtn} onClick={() => handleDeleteReference(selectedRef.id)}>
                        Delete
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Add Modal */}
          {isAddModalOpen && (
            <div 
              style={styles.modalOverlay} 
              onMouseDown={handleOverlayMouseDown}
              onClick={e => handleOverlayClick(e, () => setIsAddModalOpen(false))}
            >
              <div style={styles.addModal}>
                <button style={styles.modalClose} onClick={() => setIsAddModalOpen(false)}>‚úï</button>
                <h2 style={styles.modalTitle}>Add New Reference</h2>

                {/* Type */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Type</label>
                  <div style={styles.typeToggle}>
                    <button
                      style={{ ...styles.typeButton, ...(newRef.type === 'web' ? styles.typeButtonActive : {}) }}
                      onClick={() => setNewRef(p => ({ ...p, type: 'web', category: 'Landing' }))}
                    >
                      ‚óé Web
                    </button>
                    <button
                      style={{ ...styles.typeButton, ...(newRef.type === 'mobile' ? styles.typeButtonActive : {}) }}
                      onClick={() => setNewRef(p => ({ ...p, type: 'mobile', category: 'iOS' }))}
                    >
                      ‚óê Mobile
                    </button>
                    <button
                      style={{ ...styles.typeButton, ...(newRef.type === 'graphic' ? styles.typeButtonActive : {}) }}
                      onClick={() => setNewRef(p => ({ ...p, type: 'graphic', category: 'Poster' }))}
                    >
                      ‚óà Graphic
                    </button>
                    <button
                      style={{ ...styles.typeButton, ...(newRef.type === 'component' ? styles.typeButtonActive : {}) }}
                      onClick={() => setNewRef(p => ({ ...p, type: 'component', category: 'Navigation' }))}
                    >
                      ‚ó´ Component
                    </button>
                  </div>
                </div>

                {/* Images */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>
                    Images {(newRef.type === 'web' || newRef.type === 'mobile' || newRef.type === 'graphic') ? '(Ïó¨Îü¨ Ïû• Í∞ÄÎä•)' : '(1Ïû•)'} 
                    <span style={styles.labelHint}> - ÎìúÎûòÍ∑∏, Î∂ôÏó¨ÎÑ£Í∏∞(Ctrl+V) Í∞ÄÎä•</span>
                  </label>
                  <div 
                    style={{
                      ...styles.imageUploadArea,
                      ...(isDragging ? styles.imageUploadAreaDragging : {})
                    }}
                    onDragOver={handleDragOver}
                    onDragLeave={handleDragLeave}
                    onDrop={e => handleDrop(e, false)}
                    onPaste={e => handlePaste(e, false)}
                    tabIndex={0}
                  >
                    {newRef.images.map(img => (
                      <div key={img.id} style={styles.uploadedImage}>
                        <img src={img.src} alt="" style={styles.uploadedThumb} />
                        <button style={styles.removeImgBtn} onClick={() => handleRemoveImage(img.id)}>‚úï</button>
                        <textarea
                          placeholder="Ïù¥ÎØ∏ÏßÄ ÏÑ§Î™Ö..."
                          value={img.note}
                          onChange={e => handleImageNoteChange(img.id, e.target.value)}
                          style={styles.imgNoteInput}
                        />
                        {(newRef.type === 'web' || newRef.type === 'mobile' || newRef.type === 'graphic') && (
                          <label style={styles.componentCheckbox}>
                            <input
                              type="checkbox"
                              checked={img.isComponent || false}
                              onChange={() => handleToggleComponent(img.id)}
                            />
                            <span>ComponentÎ°ú Ï∂îÍ∞Ä</span>
                          </label>
                        )}
                      </div>
                    ))}
                    {(newRef.type === 'web' || newRef.type === 'mobile' || newRef.type === 'graphic' || newRef.images.length === 0) && (
                      <label style={{...styles.addImageBtn, ...(isDragging ? styles.addImageBtnDragging : {})}}>
                        {isDragging ? 'Ïó¨Í∏∞Ïóê ÎÜìÏúºÏÑ∏Ïöî' : '+ Add Image'}
                        <input
                          type="file"
                          accept="image/*"
                          multiple={newRef.type !== 'component'}
                          onChange={e => handleImageUpload(e)}
                          style={{ display: 'none' }}
                        />
                      </label>
                    )}
                  </div>
                </div>

                {/* Title */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Title *</label>
                  <input
                    type="text"
                    value={newRef.title}
                    onChange={e => setNewRef(p => ({ ...p, title: e.target.value }))}
                    style={styles.input}
                    placeholder="e.g., Linear Homepage"
                  />
                </div>

                {/* URL */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>URL</label>
                  <input
                    type="url"
                    value={newRef.url}
                    onChange={e => setNewRef(p => ({ ...p, url: e.target.value }))}
                    style={styles.input}
                    placeholder="https://example.com"
                  />
                </div>

                {/* Category */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Category</label>
                  <div style={styles.categoryInputWrapper} ref={categoryInputRef}>
                    <input
                      type="text"
                      value={newRef.category}
                      onChange={e => { setNewRef(p => ({ ...p, category: e.target.value })); setShowCategorySuggestions(true); }}
                      onFocus={() => setShowCategorySuggestions(true)}
                      onBlur={handleCategoryInputBlur}
                      onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); handleAddCategory(newRef.type, newRef.category); } }}
                      style={styles.input}
                      placeholder="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉù ÎòêÎäî ÏûÖÎ†•"
                    />
                    {showCategorySuggestions && allCategories[newRef.type]?.length > 0 && (
                      <div style={styles.categorySuggestions}>
                        {allCategories[newRef.type]
                          .filter(cat => cat.toLowerCase().includes(newRef.category.toLowerCase()))
                          .map(cat => (
                            <button 
                              key={cat} 
                              style={styles.categorySuggestion}
                              onMouseDown={e => e.preventDefault()}
                              onClick={() => { setNewRef(p => ({ ...p, category: cat })); setShowCategorySuggestions(false); }}
                            >
                              {cat}
                            </button>
                          ))}
                        {newRef.category && !allCategories[newRef.type]?.includes(newRef.category) && (
                          <button 
                            style={styles.categorySuggestionNew}
                            onMouseDown={e => e.preventDefault()}
                            onClick={() => handleAddCategory(newRef.type, newRef.category)}
                          >
                            + "{newRef.category}" Ï∂îÍ∞Ä
                          </button>
                        )}
                      </div>
                    )}
                  </div>
                </div>

                {/* Tags */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Tags</label>
                  <div style={styles.tagsContainer}>
                    {newRef.tags.map(tag => (
                      <span key={tag} style={styles.tagChip}>
                        {tag}
                        <button style={styles.tagRemove} onClick={() => handleRemoveTag(tag)}>√ó</button>
                      </span>
                    ))}
                  </div>
                  <div style={styles.tagInputWrapper} ref={tagInputRef}>
                    <input
                      type="text"
                      value={tagInput}
                      onChange={e => { setTagInput(e.target.value); setShowTagSuggestions(true); }}
                      onFocus={() => setShowTagSuggestions(true)}
                      onBlur={handleTagInputBlur}
                      onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); handleAddTag(tagInput); } }}
                      style={styles.input}
                      placeholder="ÌÉúÍ∑∏ ÏûÖÎ†• ÌõÑ Enter"
                    />
                    {showTagSuggestions && filteredTagSuggestions.length > 0 && (
                      <div style={styles.tagSuggestions}>
                        {filteredTagSuggestions.map(tag => (
                          <button key={tag} style={styles.tagSuggestion} onMouseDown={e => e.preventDefault()} onClick={() => handleAddTag(tag)}>
                            {tag}
                          </button>
                        ))}
                      </div>
                    )}
                  </div>
                </div>

                {/* Color */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Colors (Îã§Ï§ë ÏÑ†ÌÉù Í∞ÄÎä•)</label>
                  <div style={styles.colorPicker}>
                    {COLOR_OPTIONS.map(c => (
                      <button
                        key={c.id}
                        style={{
                          ...styles.colorBtn,
                          backgroundColor: c.color,
                          ...(newRef.colors?.includes(c.id) ? styles.colorBtnActive : {})
                        }}
                        onClick={() => setNewRef(p => ({ 
                          ...p, 
                          colors: p.colors?.includes(c.id) 
                            ? p.colors.filter(x => x !== c.id) 
                            : [...(p.colors || []), c.id]
                        }))}
                      />
                    ))}
                  </div>
                  <div style={styles.hexInputRow}>
                    <input
                      type="text"
                      placeholder="#FFFFFF"
                      value={newRef.hexColor || ''}
                      onChange={e => setNewRef(p => ({ ...p, hexColor: e.target.value }))}
                      style={styles.hexInput}
                      maxLength={7}
                    />
                    {newRef.hexColor && /^#[0-9A-Fa-f]{6}$/.test(newRef.hexColor) && (
                      <span style={{ ...styles.hexPreview, backgroundColor: newRef.hexColor }}></span>
                    )}
                  </div>
                </div>

                {/* Visibility */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Ï†ÄÏû• ÏúÑÏπò</label>
                  <div style={styles.visibilityToggle}>
                    <button
                      style={{...styles.visibilityBtn, ...(newRef.visibility === 'public' ? styles.visibilityBtnActive : {})}}
                      onClick={() => setNewRef(p => ({ ...p, visibility: 'public', targetTeamId: '' }))}
                    >
                      üåê Í≥µÏö© Î≥¥Îìú
                    </button>
                    <button
                      style={{...styles.visibilityBtn, ...(newRef.visibility === 'team' ? styles.visibilityBtnActive : {})}}
                      onClick={() => setNewRef(p => ({ ...p, visibility: 'team', targetTeamId: teamId || '' }))}
                    >
                      üë• ÌåÄ Î≥¥Îìú
                    </button>
                  </div>
                  {newRef.visibility === 'team' && (
                    <div style={{marginTop: '8px'}}>
                      <input
                        type="text"
                        placeholder="ÌåÄ Î≥¥Îìú ID (Ïòà: abc123)"
                        value={newRef.targetTeamId || ''}
                        onChange={e => setNewRef(p => ({ ...p, targetTeamId: e.target.value }))}
                        style={styles.input}
                      />
                      <p style={styles.visibilityHint}>
                        ÌåÄ Î≥¥Îìú URL: {window.location.origin}/t/{newRef.targetTeamId || '???'}
                      </p>
                    </div>
                  )}
                  {newRef.visibility !== 'team' && (
                    <p style={styles.visibilityHint}>Î™®Îì† ÏÇ¨Ïö©ÏûêÍ∞Ä Î≥º Ïàò ÏûàÏäµÎãàÎã§</p>
                  )}
                </div>

                <button style={styles.submitBtn} onClick={handleAddReference}>
                  Add Reference
                </button>
              </div>
            </div>
          )}

          {/* Edit Modal */}
          {isEditModalOpen && editRef && (
            <div 
              style={styles.modalOverlay} 
              onMouseDown={handleOverlayMouseDown}
              onClick={e => handleOverlayClick(e, () => setIsEditModalOpen(false))}
            >
              <div style={styles.addModal}>
                <button style={styles.modalClose} onClick={() => setIsEditModalOpen(false)}>‚úï</button>
                <h2 style={styles.modalTitle}>Edit Reference</h2>

                {/* Type */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Type</label>
                  <div style={styles.typeToggle}>
                    <button
                      style={{ ...styles.typeButton, ...(editRef.type === 'web' ? styles.typeButtonActive : {}) }}
                      onClick={() => setEditRef(p => ({ ...p, type: 'web' }))}
                    >
                      ‚óé Web
                    </button>
                    <button
                      style={{ ...styles.typeButton, ...(editRef.type === 'mobile' ? styles.typeButtonActive : {}) }}
                      onClick={() => setEditRef(p => ({ ...p, type: 'mobile' }))}
                    >
                      ‚óê Mobile
                    </button>
                    <button
                      style={{ ...styles.typeButton, ...(editRef.type === 'graphic' ? styles.typeButtonActive : {}) }}
                      onClick={() => setEditRef(p => ({ ...p, type: 'graphic' }))}
                    >
                      ‚óà Graphic
                    </button>
                    <button
                      style={{ ...styles.typeButton, ...(editRef.type === 'component' ? styles.typeButtonActive : {}) }}
                      onClick={() => setEditRef(p => ({ ...p, type: 'component' }))}
                    >
                      ‚ó´ Component
                    </button>
                  </div>
                </div>

                {/* Images */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>
                    Images
                    <span style={styles.labelHint}> - ÎìúÎûòÍ∑∏, Î∂ôÏó¨ÎÑ£Í∏∞(Ctrl+V) Í∞ÄÎä•</span>
                  </label>
                  <div 
                    style={{
                      ...styles.imageUploadArea,
                      ...(isDragging ? styles.imageUploadAreaDragging : {})
                    }}
                    onDragOver={handleDragOver}
                    onDragLeave={handleDragLeave}
                    onDrop={e => handleDrop(e, true)}
                    onPaste={e => handlePaste(e, true)}
                    tabIndex={0}
                  >
                    {editRef.images.map(img => (
                      <div key={img.id} style={styles.uploadedImage}>
                        <img src={img.src} alt="" style={styles.uploadedThumb} />
                        <button style={styles.removeImgBtn} onClick={() => handleRemoveImage(img.id, true)}>‚úï</button>
                        <textarea
                          placeholder="Ïù¥ÎØ∏ÏßÄ ÏÑ§Î™Ö..."
                          value={img.note}
                          onChange={e => handleImageNoteChange(img.id, e.target.value, true)}
                          style={styles.imgNoteInput}
                        />
                        {editRef.type !== 'component' && (
                          <label style={styles.componentCheckbox}>
                            <input
                              type="checkbox"
                              checked={img.isComponent || false}
                              onChange={() => handleToggleComponent(img.id, true)}
                            />
                            <span>ComponentÎ°ú Ï∂îÍ∞Ä</span>
                          </label>
                        )}
                      </div>
                    ))}
                    {(editRef.type !== 'component' || editRef.images.length === 0) && (
                      <label style={{...styles.addImageBtn, ...(isDragging ? styles.addImageBtnDragging : {})}}>
                        {isDragging ? 'Ïó¨Í∏∞Ïóê ÎÜìÏúºÏÑ∏Ïöî' : '+ Add Image'}
                        <input
                          type="file"
                          accept="image/*"
                          multiple={editRef.type !== 'component'}
                          onChange={e => handleImageUpload(e, true)}
                          style={{ display: 'none' }}
                        />
                      </label>
                    )}
                  </div>
                </div>

                {/* Title */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Title *</label>
                  <input
                    type="text"
                    value={editRef.title}
                    onChange={e => setEditRef(p => ({ ...p, title: e.target.value }))}
                    style={styles.input}
                  />
                </div>

                {/* URL */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>URL</label>
                  <input
                    type="url"
                    value={editRef.url || ''}
                    onChange={e => setEditRef(p => ({ ...p, url: e.target.value }))}
                    style={styles.input}
                  />
                </div>

                {/* Category */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Category</label>
                  <div style={styles.categoryInputWrapper}>
                    <input
                      type="text"
                      value={editRef.category}
                      onChange={e => { setEditRef(p => ({ ...p, category: e.target.value })); setShowCategorySuggestions(true); }}
                      onFocus={() => setShowCategorySuggestions(true)}
                      style={styles.input}
                      placeholder="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉù ÎòêÎäî ÏûÖÎ†•"
                    />
                    {showCategorySuggestions && allCategories[editRef.type]?.length > 0 && (
                      <div style={styles.categorySuggestions}>
                        {allCategories[editRef.type]
                          .filter(cat => cat.toLowerCase().includes((editRef.category || '').toLowerCase()))
                          .map(cat => (
                            <button 
                              key={cat} 
                              style={styles.categorySuggestion} 
                              onClick={() => { setEditRef(p => ({ ...p, category: cat })); setShowCategorySuggestions(false); }}
                            >
                              {cat}
                            </button>
                          ))}
                      </div>
                    )}
                  </div>
                </div>

                {/* Tags */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Tags</label>
                  <div style={styles.tagsContainer}>
                    {editRef.tags?.map(tag => (
                      <span key={tag} style={styles.tagChip}>
                        {tag}
                        <button style={styles.tagRemove} onClick={() => handleRemoveTag(tag, true)}>√ó</button>
                      </span>
                    ))}
                  </div>
                  <div style={styles.tagInputWrapper}>
                    <input
                      type="text"
                      value={tagInput}
                      onChange={e => { setTagInput(e.target.value); setShowTagSuggestions(true); }}
                      onFocus={() => setShowTagSuggestions(true)}
                      onBlur={handleTagInputBlur}
                      onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); handleAddTag(tagInput, true); } }}
                      style={styles.input}
                      placeholder="ÌÉúÍ∑∏ ÏûÖÎ†• ÌõÑ Enter"
                    />
                    {showTagSuggestions && filteredTagSuggestions.length > 0 && (
                      <div style={styles.tagSuggestions}>
                        {filteredTagSuggestions.map(tag => (
                          <button key={tag} style={styles.tagSuggestion} onMouseDown={e => e.preventDefault()} onClick={() => handleAddTag(tag, true)}>
                            {tag}
                          </button>
                        ))}
                      </div>
                    )}
                  </div>
                </div>

                {/* Color */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Colors (Îã§Ï§ë ÏÑ†ÌÉù Í∞ÄÎä•)</label>
                  <div style={styles.colorPicker}>
                    {COLOR_OPTIONS.map(c => (
                      <button
                        key={c.id}
                        style={{
                          ...styles.colorBtn,
                          backgroundColor: c.color,
                          ...(editRef.colors?.includes(c.id) ? styles.colorBtnActive : {})
                        }}
                        onClick={() => setEditRef(p => ({ 
                          ...p, 
                          colors: p.colors?.includes(c.id) 
                            ? p.colors.filter(x => x !== c.id) 
                            : [...(p.colors || []), c.id]
                        }))}
                      />
                    ))}
                  </div>
                  <div style={styles.hexInputRow}>
                    <input
                      type="text"
                      placeholder="#FFFFFF"
                      value={editRef.hexColor || ''}
                      onChange={e => setEditRef(p => ({ ...p, hexColor: e.target.value }))}
                      style={styles.hexInput}
                      maxLength={7}
                    />
                    {editRef.hexColor && /^#[0-9A-Fa-f]{6}$/.test(editRef.hexColor) && (
                      <span style={{ ...styles.hexPreview, backgroundColor: editRef.hexColor }}></span>
                    )}
                  </div>
                </div>

                {/* Visibility - Î≥¥Îìú Ïù¥Îèô */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Ï†ÄÏû• ÏúÑÏπò</label>
                  <div style={styles.visibilityToggle}>
                    <button
                      style={{...styles.visibilityBtn, ...(editRef.visibility === 'public' || (!editRef.visibility && !editRef.boardId) ? styles.visibilityBtnActive : {})}}
                      onClick={() => setEditRef(p => ({ ...p, visibility: 'public', targetTeamId: '' }))}
                    >
                      üåê Í≥µÏö© Î≥¥Îìú
                    </button>
                    <button
                      style={{...styles.visibilityBtn, ...(editRef.visibility === 'team' ? styles.visibilityBtnActive : {})}}
                      onClick={() => setEditRef(p => ({ ...p, visibility: 'team', targetTeamId: p.boardId && p.boardId !== 'public' ? p.boardId : (teamId || '') }))}
                    >
                      üë• ÌåÄ Î≥¥Îìú
                    </button>
                  </div>
                  {editRef.visibility === 'team' && (
                    <div style={{marginTop: '8px'}}>
                      <input
                        type="text"
                        placeholder="ÌåÄ Î≥¥Îìú ID (Ïòà: abc123)"
                        value={editRef.targetTeamId || ''}
                        onChange={e => setEditRef(p => ({ ...p, targetTeamId: e.target.value }))}
                        style={styles.input}
                      />
                      <p style={styles.visibilityHint}>
                        ÌåÄ Î≥¥Îìú URL: {window.location.origin}/t/{editRef.targetTeamId || '???'}
                      </p>
                    </div>
                  )}
                  {editRef.visibility !== 'team' && (
                    <p style={styles.visibilityHint}>Î™®Îì† ÏÇ¨Ïö©ÏûêÍ∞Ä Î≥º Ïàò ÏûàÏäµÎãàÎã§</p>
                  )}
                </div>

                <div style={styles.editBtns}>
                  <button style={styles.cancelBtn} onClick={() => setIsEditModalOpen(false)}>Cancel</button>
                  <button style={styles.submitBtn} onClick={handleSaveEdit}>Save Changes</button>
                </div>
              </div>
            </div>
          )}

          {/* Image Zoom */}
          {imageZoom && (
            <div style={styles.zoomOverlay} onClick={() => setImageZoom(null)}>
              <img src={imageZoom} alt="" style={styles.zoomImage} />
            </div>
          )}
        </div>
      );
    }

    const styles = {
      container: { minHeight: '100vh', padding: '20px' },
      header: { maxWidth: '1400px', margin: '0 auto 30px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' },
      headerInner: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%' },
      logo: { display: 'flex', alignItems: 'center', gap: '8px' },
      logoIcon: { fontSize: '28px', color: '#6366f1' },
      logoText: { fontSize: '24px', fontWeight: '700', fontFamily: '"Space Grotesk", sans-serif' },
      teamBadge: { fontSize: '12px', background: '#ecfdf5', color: '#059669', padding: '4px 10px', borderRadius: '6px', marginLeft: '12px', fontWeight: '500' },
      headerActions: { display: 'flex', gap: '8px', alignItems: 'center' },
      headerBtn: { padding: '8px 16px', background: '#f5f5f5', border: 'none', borderRadius: '8px', cursor: 'pointer', fontSize: '13px', fontFamily: '"Outfit", sans-serif', color: '#555' },
      addButton: { padding: '10px 20px', background: 'linear-gradient(135deg, #6366f1, #8b5cf6)', color: '#fff', border: 'none', borderRadius: '10px', fontWeight: '600', cursor: 'pointer', fontFamily: '"Outfit", sans-serif' },
      visibilityToggle: { display: 'flex', gap: '8px', marginBottom: '8px' },
      visibilityBtn: { flex: 1, padding: '12px', background: '#f5f5f5', border: '2px solid transparent', borderRadius: '8px', cursor: 'pointer', fontSize: '14px', fontFamily: '"Outfit", sans-serif', textAlign: 'center' },
      visibilityBtnActive: { background: '#f0f0ff', borderColor: '#6366f1', color: '#6366f1' },
      visibilityHint: { fontSize: '12px', color: '#888', marginTop: '4px' },
      filterSection: { maxWidth: '1400px', margin: '0 auto 20px', display: 'flex', gap: '16px', alignItems: 'center', flexWrap: 'wrap' },
      typeToggle: { display: 'flex', gap: '8px' },
      typeButton: { padding: '8px 16px', background: '#fff', border: '1px solid #e5e7eb', borderRadius: '8px', cursor: 'pointer', fontFamily: '"Outfit", sans-serif', fontSize: '14px' },
      typeButtonActive: { background: '#6366f1', color: '#fff', borderColor: '#6366f1' },
      searchWrapper: { position: 'relative', display: 'flex', alignItems: 'center', flex: 1, maxWidth: '400px', minWidth: '280px' },
      searchIcon: { position: 'absolute', left: '14px', fontSize: '16px', pointerEvents: 'none', opacity: 0.5 },
      searchInput: { width: '100%', padding: '12px 40px 12px 42px', border: '1px solid #e5e7eb', borderRadius: '12px', fontSize: '14px', fontFamily: '"Outfit", sans-serif', background: '#fff', boxShadow: '0 2px 4px rgba(0,0,0,0.02)' },
      searchClear: { position: 'absolute', right: '12px', background: 'none', border: 'none', fontSize: '16px', cursor: 'pointer', color: '#999', padding: '4px' },
      categoryFilter: { maxWidth: '1400px', margin: '0 auto 20px', display: 'flex', gap: '8px', flexWrap: 'wrap' },
      catButton: { padding: '6px 12px', background: '#fff', border: '1px solid #e5e7eb', borderRadius: '6px', cursor: 'pointer', fontSize: '13px', fontFamily: '"Outfit", sans-serif' },
      catButtonActive: { background: '#f0f0ff', borderColor: '#6366f1', color: '#6366f1' },
      grid: { maxWidth: '1400px', margin: '0 auto', display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))', gap: '20px' },
      card: { background: '#fff', borderRadius: '16px', overflow: 'hidden', cursor: 'pointer', boxShadow: '0 2px 8px rgba(0,0,0,0.06)', transition: 'transform 0.2s, box-shadow 0.2s' },
      cardImageWrapper: { position: 'relative', aspectRatio: '16/10', overflow: 'hidden' },
      cardImage: { width: '100%', height: '100%', objectFit: 'cover' },
      imageCount: { position: 'absolute', top: '8px', right: '8px', background: 'rgba(0,0,0,0.6)', color: '#fff', padding: '4px 8px', borderRadius: '4px', fontSize: '12px' },
      figmaBadge: { position: 'absolute', bottom: '8px', right: '8px', background: '#6366f1', color: '#fff', padding: '4px 8px', borderRadius: '4px', fontSize: '12px' },
      cardContent: { padding: '16px' },
      cardTitle: { fontSize: '16px', fontWeight: '600', marginBottom: '8px', fontFamily: '"Space Grotesk", sans-serif' },
      cardTags: { display: 'flex', gap: '6px', flexWrap: 'wrap' },
      cardTag: { fontSize: '12px', color: '#6366f1', background: '#f0f0ff', padding: '2px 8px', borderRadius: '4px' },
      modalOverlay: { position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000, padding: '20px' },
      modal: { background: '#fff', borderRadius: '20px', maxWidth: '900px', width: '100%', maxHeight: '90vh', overflow: 'auto', position: 'relative' },
      addModal: { background: '#fff', borderRadius: '20px', maxWidth: '720px', width: '100%', maxHeight: '90vh', overflow: 'auto', padding: '32px', position: 'relative' },
      modalClose: { position: 'absolute', top: '16px', right: '16px', width: '36px', height: '36px', background: '#f5f5f5', border: 'none', borderRadius: '50%', cursor: 'pointer', fontSize: '18px', zIndex: 10 },
      imageGallery: { position: 'relative' },
      modalImage: { width: '100%', maxHeight: '400px', objectFit: 'contain', background: '#f5f5f5', cursor: 'zoom-in' },
      imageThumbs: { display: 'flex', gap: '8px', padding: '12px', background: '#f9f9f9', overflowX: 'auto' },
      thumbImg: { width: '60px', height: '40px', objectFit: 'cover', borderRadius: '4px', cursor: 'pointer', opacity: 0.6, transition: 'opacity 0.2s' },
      thumbImgActive: { opacity: 1, boxShadow: '0 0 0 2px #6366f1' },
      modalContent: { padding: '24px' },
      modalMeta: { display: 'flex', gap: '8px', alignItems: 'center', color: '#888', fontSize: '14px', marginBottom: '8px' },
      modalType: { color: '#6366f1', fontWeight: '600' },
      modalTitle: { fontSize: '24px', fontWeight: '700', marginBottom: '12px', fontFamily: '"Space Grotesk", sans-serif' },
      modalUrl: { display: 'inline-block', color: '#6366f1', fontSize: '14px', marginBottom: '12px', textDecoration: 'none' },
      modalNote: { color: '#555', fontSize: '15px', lineHeight: 1.6, marginBottom: '16px', padding: '16px', background: '#f9f9f9', borderRadius: '8px', minHeight: '60px' },
      modalTags: { display: 'flex', gap: '8px', flexWrap: 'wrap' },
      modalTag: { fontSize: '13px', color: '#6366f1', background: '#f0f0ff', padding: '4px 12px', borderRadius: '6px' },
      tagsColorRow: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px', flexWrap: 'wrap', gap: '12px' },
      modalColors: { display: 'flex', gap: '8px', alignItems: 'center' },
      colorLabel: { fontSize: '13px', color: '#888', marginRight: '4px' },
      colorDot: { width: '24px', height: '24px', borderRadius: '50%', border: '2px solid #e5e7eb', cursor: 'default' },
      figmaSection: { marginBottom: '20px' },
      figmaHeader: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' },
      copyBtn: { padding: '8px 16px', background: '#6366f1', color: '#fff', border: 'none', borderRadius: '6px', cursor: 'pointer', fontSize: '13px', fontWeight: '500', transition: 'all 0.2s' },
      copyBtnSuccess: { background: '#22c55e' },
      figmaCode: { background: '#1e1e2e', color: '#a5d6ff', padding: '16px', borderRadius: '8px', fontSize: '12px', fontFamily: 'monospace', overflow: 'auto', height: '200px', whiteSpace: 'pre-wrap', wordBreak: 'break-all' },
      figmaHint: { marginTop: '8px', fontSize: '12px', color: '#888', fontStyle: 'italic' },
      generateBtn: { width: '100%', padding: '14px', background: '#fff', color: '#6366f1', border: '2px solid transparent', borderRadius: '10px', fontWeight: '600', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', fontFamily: '"Outfit", sans-serif', backgroundImage: 'linear-gradient(#fff, #fff), linear-gradient(135deg, #6366f1, #8b5cf6)', backgroundOrigin: 'border-box', backgroundClip: 'padding-box, border-box' },
      generateBtnDisabled: { opacity: 0.6, cursor: 'not-allowed' },
      spinner: { width: '16px', height: '16px', border: '2px solid rgba(99,102,241,0.3)', borderTopColor: '#6366f1', borderRadius: '50%', animation: 'spin 0.8s linear infinite' },
      modalFooter: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', paddingTop: '16px', borderTop: '1px solid #eee' },
      modalActions: { display: 'flex', gap: '8px' },
      editBtn: { padding: '8px 16px', background: '#f0f0f5', border: 'none', borderRadius: '8px', cursor: 'pointer', fontFamily: '"Outfit", sans-serif' },
      deleteBtn: { padding: '8px 16px', background: '#fee2e2', color: '#dc2626', border: 'none', borderRadius: '8px', cursor: 'pointer', fontFamily: '"Outfit", sans-serif' },
      formGroup: { marginBottom: '20px' },
      label: { display: 'block', fontSize: '14px', fontWeight: '600', marginBottom: '8px', color: '#333' },
      labelHint: { fontSize: '12px', fontWeight: '400', color: '#999' },
      input: { width: '100%', padding: '12px', border: '1px solid #e5e7eb', borderRadius: '8px', fontSize: '14px', fontFamily: '"Outfit", sans-serif' },
      select: { width: '100%', padding: '12px', border: '1px solid #e5e7eb', borderRadius: '8px', fontSize: '14px', fontFamily: '"Outfit", sans-serif' },
      imageUploadArea: { display: 'flex', flexWrap: 'wrap', gap: '16px', padding: '16px', border: '2px dashed transparent', borderRadius: '12px', transition: 'all 0.2s', outline: 'none', minHeight: '160px' },
      imageUploadAreaDragging: { borderColor: '#6366f1', background: '#f0f0ff' },
      uploadedImage: { position: 'relative', width: '180px' },
      uploadedThumb: { width: '180px', height: '120px', objectFit: 'cover', borderRadius: '8px' },
      removeImgBtn: { position: 'absolute', top: '-8px', right: '-8px', width: '24px', height: '24px', background: '#ef4444', color: '#fff', border: 'none', borderRadius: '50%', cursor: 'pointer', fontSize: '14px', fontWeight: 'bold' },
      imgNoteInput: { width: '100%', marginTop: '8px', padding: '10px', border: '1px solid #e5e7eb', borderRadius: '6px', fontSize: '13px', fontFamily: '"Outfit", sans-serif', resize: 'vertical', minHeight: '60px' },
      addImageBtn: { width: '180px', height: '120px', border: '2px dashed #d1d5db', borderRadius: '8px', display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', color: '#9ca3af', fontSize: '14px', fontFamily: '"Outfit", sans-serif', transition: 'all 0.2s', flexDirection: 'column', gap: '8px' },
      addImageBtnDragging: { borderColor: '#6366f1', color: '#6366f1', background: '#f0f0ff' },
      tagsContainer: { display: 'flex', flexWrap: 'wrap', gap: '8px', marginBottom: '8px' },
      tagChip: { display: 'flex', alignItems: 'center', gap: '4px', background: '#f0f0ff', color: '#6366f1', padding: '4px 10px', borderRadius: '6px', fontSize: '13px' },
      tagRemove: { background: 'none', border: 'none', color: '#6366f1', cursor: 'pointer', fontSize: '16px', padding: 0 },
      tagInputWrapper: { position: 'relative' },
      tagSuggestions: { position: 'absolute', bottom: '100%', left: 0, right: 0, background: '#fff', border: '1px solid #e5e7eb', borderRadius: '8px', boxShadow: '0 -4px 12px rgba(0,0,0,0.1)', zIndex: 10, maxHeight: '200px', overflow: 'auto', marginBottom: '4px' },
      tagSuggestion: { display: 'block', width: '100%', padding: '10px 12px', border: 'none', background: 'none', textAlign: 'left', cursor: 'pointer', fontSize: '13px', fontFamily: '"Outfit", sans-serif' },
      categoryInputWrapper: { position: 'relative' },
      categorySuggestions: { position: 'absolute', bottom: '100%', left: 0, right: 0, background: '#fff', border: '1px solid #e5e7eb', borderRadius: '8px', boxShadow: '0 -4px 12px rgba(0,0,0,0.1)', zIndex: 10, maxHeight: '200px', overflow: 'auto', marginBottom: '4px' },
      categorySuggestion: { display: 'block', width: '100%', padding: '10px 12px', border: 'none', background: 'none', textAlign: 'left', cursor: 'pointer', fontSize: '13px', fontFamily: '"Outfit", sans-serif' },
      categorySuggestionNew: { display: 'block', width: '100%', padding: '10px 12px', border: 'none', background: '#f0fdf4', color: '#16a34a', textAlign: 'left', cursor: 'pointer', fontSize: '13px', fontFamily: '"Outfit", sans-serif', fontWeight: '500' },
      colorPicker: { display: 'flex', gap: '8px', flexWrap: 'wrap', marginBottom: '12px' },
      colorBtn: { width: '32px', height: '32px', borderRadius: '50%', border: '2px solid transparent', cursor: 'pointer', transition: 'transform 0.2s, box-shadow 0.2s' },
      colorBtnActive: { transform: 'scale(1.15)', boxShadow: '0 0 0 3px rgba(99,102,241,0.4)' },
      hexInputRow: { display: 'flex', gap: '8px', alignItems: 'center' },
      hexInput: { width: '120px', padding: '8px 12px', border: '1px solid #e5e7eb', borderRadius: '6px', fontSize: '13px', fontFamily: 'monospace' },
      hexPreview: { width: '32px', height: '32px', borderRadius: '6px', border: '1px solid #e5e7eb' },
      componentCheckbox: { display: 'flex', alignItems: 'center', gap: '6px', marginTop: '6px', fontSize: '12px', color: '#6366f1', cursor: 'pointer' },
      submitBtn: { width: '100%', padding: '14px', background: 'linear-gradient(135deg, #6366f1, #8b5cf6)', color: '#fff', border: 'none', borderRadius: '10px', fontWeight: '600', cursor: 'pointer', fontSize: '15px', fontFamily: '"Outfit", sans-serif' },
      editBtns: { display: 'flex', gap: '12px' },
      cancelBtn: { flex: 1, padding: '14px', background: '#f0f0f5', border: 'none', borderRadius: '10px', cursor: 'pointer', fontFamily: '"Outfit", sans-serif' },
      categoryFilterSection: { maxWidth: '1400px', margin: '0 auto 16px', display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap', padding: '12px 16px', background: '#fff', borderRadius: '12px', boxShadow: '0 1px 3px rgba(0,0,0,0.05)' },
      filterLabel: { fontSize: '13px', color: '#888', fontWeight: '600', minWidth: '70px' },
      categoryFilter: { display: 'flex', gap: '8px', flexWrap: 'wrap' },
      catButton: { padding: '6px 14px', background: '#f5f5f5', border: 'none', borderRadius: '6px', cursor: 'pointer', fontSize: '13px', fontFamily: '"Outfit", sans-serif', color: '#555', transition: 'all 0.2s' },
      catButtonActive: { background: '#6366f1', color: '#fff' },
      tagFilterSection: { maxWidth: '1400px', margin: '0 auto 20px', display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap', padding: '12px 16px', background: '#fff', borderRadius: '12px', boxShadow: '0 1px 3px rgba(0,0,0,0.05)' },
      tagFilterList: { display: 'flex', gap: '8px', flexWrap: 'wrap', alignItems: 'center' },
      tagFilterBtn: { padding: '4px 12px', background: '#f0f0ff', border: 'none', borderRadius: '6px', cursor: 'pointer', fontSize: '12px', fontFamily: '"Outfit", sans-serif', color: '#6366f1', transition: 'all 0.2s' },
      tagFilterBtnActive: { background: '#6366f1', color: '#fff' },
      clearTagsBtn: { padding: '4px 12px', background: '#fef2f2', color: '#dc2626', border: 'none', borderRadius: '6px', cursor: 'pointer', fontSize: '12px', fontFamily: '"Outfit", sans-serif' },
      zoomOverlay: { position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.95)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000, cursor: 'zoom-out' },
      zoomImage: { maxWidth: '95vw', maxHeight: '95vh', objectFit: 'contain' },
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
