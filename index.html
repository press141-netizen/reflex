<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reflex - Designer's Archive</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Outfit', sans-serif; background: linear-gradient(180deg, #FAFBFC 0%, #F5F7FA 50%, #EEF2F7 100%); min-height: 100vh; }
    @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useMemo, useEffect, useRef } = React;

    const TYPES = [
      { id: 'all', name: 'All', emoji: '‚ú¶' },
      { id: 'web', name: 'Web', emoji: '‚óé' },
      { id: 'mobile', name: 'Mobile', emoji: '‚óê' },
      { id: 'graphic', name: 'Graphic', emoji: '‚óà' },
      { id: 'component', name: 'Component', emoji: '‚ó´' },
    ];

    const DEFAULT_CATEGORIES = {
      web: ['Landing', 'Portfolio', 'E-commerce', 'Dashboard', 'Blog', 'Corporate'],
      mobile: ['iOS', 'Android', 'App', 'Onboarding'],
      graphic: ['Poster', 'Banner', 'Icon', 'Illustration', 'Logo', 'Print'],
      component: ['Navigation', 'Hero', 'Button', 'Card', 'Form', 'Modal', 'Sidebar', 'Footer'],
    };

    // ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞: images Î∞∞Ïó¥ (Í∞Å Ïù¥ÎØ∏ÏßÄÎ≥Ñ note, figmaCode, isComponent)
    const DEFAULT_REFERENCES = [
      {
        id: 1,
        type: 'web',
        title: 'Linear Homepage',
        url: 'https://linear.app',
        images: [
          { id: 'img1', src: 'https://images.unsplash.com/photo-1618005182384-a83a8bd57fbe?w=600&h=400&fit=crop', note: 'Î©îÏù∏ ÌûàÏñ¥Î°ú ÏÑπÏÖò', figmaCode: null, isComponent: false },
        ],
        category: 'landing',
        tags: ['minimal', 'dark', 'saas'],
        addedAt: '2024.12.15 AM 10:30',
      },
      {
        id: 2,
        type: 'component',
        title: 'Glass Navigation',
        url: 'https://vercel.com',
        images: [
          { id: 'img2', src: 'https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=600&h=400&fit=crop', note: 'Î∏îÎü¨ Ìö®Í≥º ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò', figmaCode: null, isComponent: false },
        ],
        category: 'navigation',
        tags: ['glassmorphism', 'blur'],
        addedAt: '2024.12.12',
      },
    ];

    function App() {
      const [references, setReferences] = useState(() => {
        const saved = localStorage.getItem('reflex-references-v2');
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            // Íµ¨ Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
            return parsed.map(ref => {
              if (ref.thumbnail && !ref.images) {
                return {
                  ...ref,
                  images: [{ id: 'migrated', src: ref.thumbnail, note: ref.note || '', figmaCode: ref.figmaCode || null }],
                };
              }
              return ref;
            });
          } catch { return DEFAULT_REFERENCES; }
        }
        return DEFAULT_REFERENCES;
      });
      
      const [activeType, setActiveType] = useState('all');
      const [activeCategory, setActiveCategory] = useState('all');
      const [searchQuery, setSearchQuery] = useState('');
      const [selectedTags, setSelectedTags] = useState([]);
      const [selectedRef, setSelectedRef] = useState(null);
      const [selectedImageIndex, setSelectedImageIndex] = useState(0);
      const [isAddModalOpen, setIsAddModalOpen] = useState(false);
      const [isEditModalOpen, setIsEditModalOpen] = useState(false);
      const [editRef, setEditRef] = useState(null);
      const [imageZoom, setImageZoom] = useState(null);
      const [isGenerating, setIsGenerating] = useState(null); // Ïù¥ÎØ∏ÏßÄ ID
      const [tagInput, setTagInput] = useState('');
      const [showTagSuggestions, setShowTagSuggestions] = useState(false);
      const [categoryInput, setCategoryInput] = useState('');
      const [showCategorySuggestions, setShowCategorySuggestions] = useState(false);
      const tagInputRef = useRef(null);
      const categoryInputRef = useRef(null);
      
      // ÎìúÎ°≠Îã§Ïö¥ Îã´Í∏∞ - blur Ïù¥Î≤§Ìä∏ ÏÇ¨Ïö© (Î™®Îã¨Í≥º Ï∂©Îèå Î∞©ÏßÄ)
      const handleTagInputBlur = (e) => {
        setTimeout(() => {
          if (!tagInputRef.current?.contains(document.activeElement)) {
            setShowTagSuggestions(false);
          }
        }, 150);
      };
      
      const handleCategoryInputBlur = (e) => {
        setTimeout(() => {
          if (!categoryInputRef.current?.contains(document.activeElement)) {
            setShowCategorySuggestions(false);
          }
        }, 150);
      };
      
      const [newRef, setNewRef] = useState({
        type: 'web',
        title: '',
        url: '',
        images: [],
        category: 'Landing',
        tags: [],
        colors: [],
        hexColor: '',
      });

      // Ïª¨Îü¨ ÏòµÏÖò
      const COLOR_OPTIONS = [
        { id: 'red', color: '#ef4444' },
        { id: 'orange', color: '#f97316' },
        { id: 'yellow', color: '#eab308' },
        { id: 'green', color: '#22c55e' },
        { id: 'blue', color: '#3b82f6' },
        { id: 'purple', color: '#8b5cf6' },
        { id: 'pink', color: '#ec4899' },
        { id: 'gray', color: '#6b7280' },
        { id: 'black', color: '#1f2937' },
        { id: 'white', color: '#f9fafb' },
      ];

      // Save to localStorage
      useEffect(() => {
        localStorage.setItem('reflex-references-v2', JSON.stringify(references));
      }, [references]);

      // Ï†ÑÏ≤¥ ÌÉúÍ∑∏ Î™©Î°ù
      const allTags = useMemo(() => {
        const tags = new Set();
        references.forEach(ref => ref.tags?.forEach(tag => tags.add(tag)));
        return Array.from(tags).sort();
      }, [references]);

      // Ïª§Ïä§ÌÖÄ Ïπ¥ÌÖåÍ≥†Î¶¨ (localStorageÏóêÏÑú Î°úÎìú)
      const [customCategories, setCustomCategories] = useState(() => {
        const saved = localStorage.getItem('reflex-custom-categories');
        return saved ? JSON.parse(saved) : { web: [], mobile: [], graphic: [], component: [] };
      });

      // Ïª§Ïä§ÌÖÄ Ïπ¥ÌÖåÍ≥†Î¶¨ Ï†ÄÏû•
      useEffect(() => {
        localStorage.setItem('reflex-custom-categories', JSON.stringify(customCategories));
      }, [customCategories]);

      // Ï†ÑÏ≤¥ Ïπ¥ÌÖåÍ≥†Î¶¨ (Í∏∞Î≥∏ + Ïª§Ïä§ÌÖÄ)
      const allCategories = useMemo(() => {
        const result = {};
        Object.keys(DEFAULT_CATEGORIES).forEach(type => {
          result[type] = [...DEFAULT_CATEGORIES[type], ...(customCategories[type] || [])];
        });
        return result;
      }, [customCategories]);

      // ÌïÑÌÑ∞ÎßÅ (Í≤ÄÏÉâÏóê note Ìè¨Ìï®)
      const filteredReferences = useMemo(() => {
        return references.filter(ref => {
          if (activeType !== 'all' && ref.type !== activeType) return false;
          if (activeCategory !== 'all' && ref.category !== activeCategory) return false;
          if (searchQuery) {
            const q = searchQuery.toLowerCase();
            const titleMatch = ref.title.toLowerCase().includes(q);
            const tagMatch = ref.tags?.some(t => t.toLowerCase().includes(q));
            const noteMatch = ref.images?.some(img => img.note?.toLowerCase().includes(q));
            if (!titleMatch && !tagMatch && !noteMatch) return false;
          }
          if (selectedTags.length > 0 && !selectedTags.every(t => ref.tags?.includes(t))) return false;
          return true;
        });
      }, [references, activeType, activeCategory, searchQuery, selectedTags]);

      // Ïù¥ÎØ∏ÏßÄ Î¶¨ÏÇ¨Ïù¥Ïßï Î∞è ÏïïÏ∂ï Ìï®Ïàò
      const resizeAndCompressImage = (file, maxWidth = 1200, maxHeight = 1200, quality = 0.7) => {
        return new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              const canvas = document.createElement('canvas');
              let { width, height } = img;
              
              // ÎπÑÏú® Ïú†ÏßÄÌïòÎ©∞ Î¶¨ÏÇ¨Ïù¥Ï¶à
              if (width > maxWidth || height > maxHeight) {
                const ratio = Math.min(maxWidth / width, maxHeight / height);
                width = Math.round(width * ratio);
                height = Math.round(height * ratio);
              }
              
              canvas.width = width;
              canvas.height = height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, width, height);
              
              // JPEGÎ°ú ÏïïÏ∂ï
              const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
              resolve({ dataUrl: compressedDataUrl, width, height });
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        });
      };

      // Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ìï∏Îì§Îü¨ (Î¶¨ÏÇ¨Ïù¥Ïßï + ÏïïÏ∂ï)
      const handleImageUpload = async (e, isEdit = false) => {
        const files = Array.from(e.target.files || []);
        for (const file of files) {
          if (file.type.startsWith('image/')) {
            const { dataUrl, width, height } = await resizeAndCompressImage(file);
            const newImage = {
              id: Date.now() + Math.random().toString(36).substr(2, 9),
              src: dataUrl,
              note: '',
              figmaCode: null,
              isComponent: false,
              width,
              height,
            };
            if (isEdit && editRef) {
              setEditRef(prev => ({ ...prev, images: [...prev.images, newImage] }));
            } else {
              setNewRef(prev => ({ ...prev, images: [...prev.images, newImage] }));
            }
          }
        }
      };

      // Ïù¥ÎØ∏ÏßÄ ÏÇ≠Ï†ú
      const handleRemoveImage = (imgId, isEdit = false) => {
        if (isEdit) {
          setEditRef(prev => ({ ...prev, images: prev.images.filter(img => img.id !== imgId) }));
        } else {
          setNewRef(prev => ({ ...prev, images: prev.images.filter(img => img.id !== imgId) }));
        }
      };

      // Ïù¥ÎØ∏ÏßÄ ÎÖ∏Ìä∏ ÏàòÏ†ï
      const handleImageNoteChange = (imgId, note, isEdit = false) => {
        if (isEdit) {
          setEditRef(prev => ({
            ...prev,
            images: prev.images.map(img => img.id === imgId ? { ...img, note } : img)
          }));
        } else {
          setNewRef(prev => ({
            ...prev,
            images: prev.images.map(img => img.id === imgId ? { ...img, note } : img)
          }));
        }
      };

      // ÌÉúÍ∑∏ Ï∂îÍ∞Ä
      const handleAddTag = (tag, isEdit = false) => {
        const trimmed = tag.trim().toLowerCase();
        if (!trimmed) return;
        if (isEdit) {
          if (!editRef.tags.includes(trimmed)) {
            setEditRef(prev => ({ ...prev, tags: [...prev.tags, trimmed] }));
          }
        } else {
          if (!newRef.tags.includes(trimmed)) {
            setNewRef(prev => ({ ...prev, tags: [...prev.tags, trimmed] }));
          }
        }
        setTagInput('');
        setShowTagSuggestions(false);
      };

      // ÌÉúÍ∑∏ Ï†úÍ±∞
      const handleRemoveTag = (tag, isEdit = false) => {
        if (isEdit) {
          setEditRef(prev => ({ ...prev, tags: prev.tags.filter(t => t !== tag) }));
        } else {
          setNewRef(prev => ({ ...prev, tags: prev.tags.filter(t => t !== tag) }));
        }
      };

      // ÌÉúÍ∑∏ Ï†úÏïà ÌïÑÌÑ∞
      const filteredTagSuggestions = useMemo(() => {
        if (!tagInput) return allTags.slice(0, 10);
        return allTags.filter(t => t.includes(tagInput.toLowerCase())).slice(0, 10);
      }, [tagInput, allTags]);

      // Ïπ¥ÌÖåÍ≥†Î¶¨ Ï∂îÍ∞Ä
      const handleAddCategory = (type, category) => {
        const trimmed = category.trim();
        if (!trimmed) return;
        if (!allCategories[type]?.includes(trimmed)) {
          setCustomCategories(prev => ({
            ...prev,
            [type]: [...(prev[type] || []), trimmed]
          }));
        }
        setCategoryInput('');
        setShowCategorySuggestions(false);
      };

      // ÎÇ†Ïßú Ìè¨Îß∑ Ìï®Ïàò
      const formatDateTime = () => {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = now.getHours();
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const ampm = hours >= 12 ? 'PM' : 'AM';
        const hour12 = String(hours % 12 || 12).padStart(2, '0');
        return `${year}.${month}.${day} ${ampm} ${hour12}:${minutes}`;
      };

      // Ïù¥ÎØ∏ÏßÄ Ïª¥Ìè¨ÎÑåÌä∏ Ï≤¥ÌÅ¨ ÌÜ†Í∏Ä
      const handleToggleComponent = (imgId, isEdit = false) => {
        if (isEdit) {
          setEditRef(prev => ({
            ...prev,
            images: prev.images.map(img => 
              img.id === imgId ? { ...img, isComponent: !img.isComponent } : img
            )
          }));
        } else {
          setNewRef(prev => ({
            ...prev,
            images: prev.images.map(img => 
              img.id === imgId ? { ...img, isComponent: !img.isComponent } : img
            )
          }));
        }
      };

      // Î†àÌçºÎü∞Ïä§ Ï∂îÍ∞Ä (Ïª¥Ìè¨ÎÑåÌä∏ ÏûêÎèô ÏÉùÏÑ± Ìè¨Ìï®)
      const handleAddReference = () => {
        if (!newRef.title || newRef.images.length === 0) {
          alert('Ï†úÎ™©Í≥º ÏµúÏÜå 1Í∞úÏùò Ïù¥ÎØ∏ÏßÄÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.');
          return;
        }
        
        const addedAt = formatDateTime();
        const reference = {
          id: Date.now(),
          ...newRef,
          addedAt,
        };
        
        // Ïª¥Ìè¨ÎÑåÌä∏Î°ú Ï≤¥ÌÅ¨Îêú Ïù¥ÎØ∏ÏßÄÎì§ ÏûêÎèô Ï∂îÍ∞Ä
        const componentImages = newRef.images.filter(img => img.isComponent);
        const componentRefs = componentImages.map((img, idx) => ({
          id: Date.now() + idx + 1,
          type: 'component',
          title: `${newRef.title} - Component`,
          url: newRef.url,
          images: [{ ...img, isComponent: false }],
          category: 'card',
          tags: [...newRef.tags],
          addedAt,
          sourceRefId: reference.id, // ÏõêÎ≥∏ Ï∞∏Ï°∞
        }));
        
        setReferences(prev => [reference, ...componentRefs, ...prev]);
        setIsAddModalOpen(false);
        setNewRef({ type: 'web', title: '', url: '', images: [], category: 'landing', tags: [] });
      };

      // Î†àÌçºÎü∞Ïä§ ÏàòÏ†ï Ï†ÄÏû•
      const handleSaveEdit = () => {
        if (!editRef.title) return;
        setReferences(prev => prev.map(ref => ref.id === editRef.id ? editRef : ref));
        setSelectedRef(editRef);
        setIsEditModalOpen(false);
      };

      // Î†àÌçºÎü∞Ïä§ ÏÇ≠Ï†ú
      const handleDeleteReference = (id) => {
        setReferences(prev => prev.filter(ref => ref.id !== id));
        setSelectedRef(null);
      };

      // Figma ÏΩîÎìú ÏÉùÏÑ± (ÌäπÏ†ï Ïù¥ÎØ∏ÏßÄ)
      const handleGenerateFigma = async (refId, imgId) => {
        const ref = references.find(r => r.id === refId);
        const img = ref?.images.find(i => i.id === imgId);
        if (!img) return;

        setIsGenerating(imgId);
        
        try {
          let base64Data = img.src;
          let mimeType = 'image/png';
          
          if (img.src.startsWith('data:')) {
            const [header, data] = img.src.split(',');
            mimeType = header.match(/data:(.*?);/)?.[1] || 'image/png';
            base64Data = data;
          } else {
            // URLÏù∏ Í≤ΩÏö∞ fetch
            const response = await fetch(img.src);
            const blob = await response.blob();
            mimeType = blob.type;
            base64Data = await new Promise(resolve => {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result.split(',')[1]);
              reader.readAsDataURL(blob);
            });
          }

          // Ïù¥ÎØ∏ÏßÄ ÌÅ¨Í∏∞
          const imgEl = new Image();
          imgEl.src = img.src;
          await new Promise(resolve => { imgEl.onload = resolve; });

          const apiResponse = await fetch('/api/analyze', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              image: base64Data,
              mimeType,
              componentName: ref.title,
              imageWidth: img.width || imgEl.naturalWidth,
              imageHeight: img.height || imgEl.naturalHeight,
              // AI Î∂ÑÏÑù Ï†ïÎ∞ÄÎèÑ Ìñ•ÏÉÅÏùÑ ÏúÑÌïú Ïª®ÌÖçÏä§Ìä∏ Ï†ïÎ≥¥
              context: {
                note: img.note || '',
                tags: ref.tags || [],
                type: ref.type,
                category: ref.category,
              },
            }),
          });

          if (!apiResponse.ok) throw new Error('API failed');
          
          const result = await apiResponse.json();
          
          if (result.figmaCode) {
            setReferences(prev => prev.map(r => {
              if (r.id !== refId) return r;
              return {
                ...r,
                images: r.images.map(i => i.id === imgId ? { ...i, figmaCode: result.figmaCode } : i)
              };
            }));
            // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ref ÏóÖÎç∞Ïù¥Ìä∏
            if (selectedRef?.id === refId) {
              setSelectedRef(prev => ({
                ...prev,
                images: prev.images.map(i => i.id === imgId ? { ...i, figmaCode: result.figmaCode } : i)
              }));
            }
          }
        } catch (error) {
          console.error('Figma ÏÉùÏÑ± Ïã§Ìå®:', error);
          alert('Figma ÏΩîÎìú ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
        } finally {
          setIsGenerating(null);
        }
      };

      // ÌÅ¥Î¶ΩÎ≥¥Îìú Î≥µÏÇ¨ (ÌîºÎìúÎ∞± Ìè¨Ìï®)
      const [copySuccess, setCopySuccess] = useState(false);
      const copyToClipboard = (code) => {
        navigator.clipboard.writeText(code);
        setCopySuccess(true);
        setTimeout(() => setCopySuccess(false), 2000);
      };

      // ÌÉúÍ∑∏ ÌÜ†Í∏Ä (Îã§Ï§ë ÏÑ†ÌÉù)
      const toggleTag = (tag) => {
        setSelectedTags(prev => 
          prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag]
        );
      };

      return (
        <div style={styles.container}>
          {/* Header */}
          <header style={styles.header}>
            <div style={styles.headerInner}>
              <div style={styles.logo}>
                <span style={styles.logoIcon}>‚óà</span>
                <span style={styles.logoText}>Reflex</span>
              </div>
              <button style={styles.addButton} onClick={() => setIsAddModalOpen(true)}>
                + Add Reference
              </button>
            </div>
          </header>

          {/* Filters */}
          <section style={styles.filterSection}>
            <div style={styles.typeToggle}>
              {TYPES.map(type => (
                <button
                  key={type.id}
                  onClick={() => { setActiveType(type.id); setActiveCategory('all'); }}
                  style={{ ...styles.typeButton, ...(activeType === type.id ? styles.typeButtonActive : {}) }}
                >
                  {type.emoji} {type.name}
                </button>
              ))}
            </div>
            <div style={styles.searchWrapper}>
              <span style={styles.searchIcon}>üîç</span>
              <input
                type="text"
                placeholder="Search by title, tags, or description..."
                value={searchQuery}
                onChange={e => setSearchQuery(e.target.value)}
                style={styles.searchInput}
              />
              {searchQuery && (
                <button style={styles.searchClear} onClick={() => setSearchQuery('')}>‚úï</button>
              )}
            </div>
          </section>

          {/* Category Filter */}
          {activeType !== 'all' && (
            <div style={styles.categoryFilterSection}>
              <span style={styles.filterLabel}>Category</span>
              <div style={styles.categoryFilter}>
                <button
                  onClick={() => setActiveCategory('all')}
                  style={{ ...styles.catButton, ...(activeCategory === 'all' ? styles.catButtonActive : {}) }}
                >
                  All
                </button>
                {allCategories[activeType]?.map(cat => (
                  <button
                    key={cat}
                    onClick={() => setActiveCategory(cat)}
                    style={{ ...styles.catButton, ...(activeCategory === cat ? styles.catButtonActive : {}) }}
                  >
                    {cat}
                  </button>
                ))}
              </div>
            </div>
          )}

          {/* Tag Filter */}
          {allTags.length > 0 && (
            <div style={styles.tagFilterSection}>
              <span style={styles.filterLabel}>Tags</span>
              <div style={styles.tagFilterList}>
                {allTags.slice(0, 15).map(tag => (
                  <button
                    key={tag}
                    onClick={() => toggleTag(tag)}
                    style={{ 
                      ...styles.tagFilterBtn, 
                      ...(selectedTags.includes(tag) ? styles.tagFilterBtnActive : {}) 
                    }}
                  >
                    {tag}
                  </button>
                ))}
                {selectedTags.length > 0 && (
                  <button style={styles.clearTagsBtn} onClick={() => setSelectedTags([])}>
                    Clear
                  </button>
                )}
              </div>
            </div>
          )}

          {/* Grid */}
          <main style={styles.grid}>
            {filteredReferences.map(ref => (
              <article key={ref.id} style={styles.card} onClick={() => { setSelectedRef(ref); setSelectedImageIndex(0); }}>
                <div style={styles.cardImageWrapper}>
                  <img src={ref.images[0]?.src} alt={ref.title} style={styles.cardImage} />
                  {ref.images.length > 1 && (
                    <span style={styles.imageCount}>+{ref.images.length - 1}</span>
                  )}
                  {ref.images.some(img => img.figmaCode) && (
                    <span style={styles.figmaBadge}>‚ó´</span>
                  )}
                </div>
                <div style={styles.cardContent}>
                  <h3 style={styles.cardTitle}>{ref.title}</h3>
                  <div style={styles.cardTags}>
                    {ref.tags?.slice(0, 3).map(tag => (
                      <span key={tag} style={styles.cardTag}>{tag}</span>
                    ))}
                  </div>
                </div>
              </article>
            ))}
          </main>

          {/* Detail Modal */}
          {selectedRef && (
            <div style={styles.modalOverlay} onClick={() => setSelectedRef(null)}>
              <div style={styles.modal} onClick={e => e.stopPropagation()}>
                <button style={styles.modalClose} onClick={() => setSelectedRef(null)}>‚úï</button>
                
                {/* Ïù¥ÎØ∏ÏßÄ Í∞§Îü¨Î¶¨ */}
                <div style={styles.imageGallery}>
                  <img
                    src={selectedRef.images[selectedImageIndex]?.src}
                    alt=""
                    style={styles.modalImage}
                    onClick={() => setImageZoom(selectedRef.images[selectedImageIndex]?.src)}
                  />
                  {selectedRef.images.length > 1 && (
                    <div style={styles.imageThumbs}>
                      {selectedRef.images.map((img, idx) => (
                        <img
                          key={img.id}
                          src={img.src}
                          alt=""
                          style={{ ...styles.thumbImg, ...(idx === selectedImageIndex ? styles.thumbImgActive : {}) }}
                          onClick={() => setSelectedImageIndex(idx)}
                        />
                      ))}
                    </div>
                  )}
                </div>

                <div style={styles.modalContent}>
                  <div style={styles.modalMeta}>
                    <span style={styles.modalType}>{TYPES.find(t => t.id === selectedRef.type)?.emoji} {selectedRef.type}</span>
                    <span>‚Ä¢</span>
                    <span>{selectedRef.category}</span>
                  </div>
                  <h2 style={styles.modalTitle}>{selectedRef.title}</h2>
                  {selectedRef.url && (
                    <a href={selectedRef.url} target="_blank" style={styles.modalUrl}>{selectedRef.url} ‚Üó</a>
                  )}
                  
                  {/* ÌòÑÏû¨ Ïù¥ÎØ∏ÏßÄ ÎÖ∏Ìä∏ */}
                  {selectedRef.images[selectedImageIndex]?.note && (
                    <p style={styles.modalNote}>{selectedRef.images[selectedImageIndex].note}</p>
                  )}

                  {/* ÌÉúÍ∑∏ */}
                  <div style={styles.modalTags}>
                    {selectedRef.tags?.map(tag => (
                      <span key={tag} style={styles.modalTag}>{tag}</span>
                    ))}
                  </div>

                  {/* Figma ÏΩîÎìú ÏÉùÏÑ±/ÌëúÏãú */}
                  <div style={styles.figmaSection}>
                    {selectedRef.images[selectedImageIndex]?.figmaCode ? (
                      <>
                        <div style={styles.figmaHeader}>
                          <span>‚ó´ Figma Code</span>
                          <button
                            style={{ ...styles.copyBtn, ...(copySuccess ? styles.copyBtnSuccess : {}) }}
                            onClick={() => copyToClipboard(selectedRef.images[selectedImageIndex].figmaCode)}
                          >
                            {copySuccess ? '‚úì Copied!' : 'Copy'}
                          </button>
                        </div>
                        <pre style={styles.figmaCode}>
                          {selectedRef.images[selectedImageIndex].figmaCode}
                        </pre>
                        <p style={styles.figmaHint}>Figma ‚Üí Plugins ‚Üí Development ‚Üí Open Console ‚Üí Î∂ôÏó¨ÎÑ£Í∏∞ ÌõÑ Ïã§Ìñâ</p>
                      </>
                    ) : (
                      <button
                        style={{ ...styles.generateBtn, ...(isGenerating ? styles.generateBtnDisabled : {}) }}
                        onClick={() => handleGenerateFigma(selectedRef.id, selectedRef.images[selectedImageIndex].id)}
                        disabled={isGenerating}
                      >
                        {isGenerating === selectedRef.images[selectedImageIndex]?.id ? (
                          <><span style={styles.spinner}></span> Generating...</>
                        ) : (
                          '‚ó´ Generate Figma Code'
                        )}
                      </button>
                    )}
                  </div>

                  <div style={styles.modalFooter}>
                    <span>{selectedRef.addedAt}</span>
                    <div style={styles.modalActions}>
                      <button style={styles.editBtn} onClick={() => { setEditRef({...selectedRef}); setIsEditModalOpen(true); }}>
                        ‚úé Edit
                      </button>
                      <button style={styles.deleteBtn} onClick={() => handleDeleteReference(selectedRef.id)}>
                        Delete
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Add Modal */}
          {isAddModalOpen && (
            <div style={styles.modalOverlay} onClick={() => setIsAddModalOpen(false)}>
              <div style={styles.addModal} onClick={e => e.stopPropagation()}>
                <button style={styles.modalClose} onClick={() => setIsAddModalOpen(false)}>‚úï</button>
                <h2 style={styles.modalTitle}>Add New Reference</h2>

                {/* Type */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Type</label>
                  <div style={styles.typeToggle}>
                    <button
                      style={{ ...styles.typeButton, ...(newRef.type === 'web' ? styles.typeButtonActive : {}) }}
                      onClick={() => setNewRef(p => ({ ...p, type: 'web', category: 'Landing' }))}
                    >
                      ‚óé Web
                    </button>
                    <button
                      style={{ ...styles.typeButton, ...(newRef.type === 'mobile' ? styles.typeButtonActive : {}) }}
                      onClick={() => setNewRef(p => ({ ...p, type: 'mobile', category: 'iOS' }))}
                    >
                      ‚óê Mobile
                    </button>
                    <button
                      style={{ ...styles.typeButton, ...(newRef.type === 'graphic' ? styles.typeButtonActive : {}) }}
                      onClick={() => setNewRef(p => ({ ...p, type: 'graphic', category: 'Poster' }))}
                    >
                      ‚óà Graphic
                    </button>
                    <button
                      style={{ ...styles.typeButton, ...(newRef.type === 'component' ? styles.typeButtonActive : {}) }}
                      onClick={() => setNewRef(p => ({ ...p, type: 'component', category: 'Navigation' }))}
                    >
                      ‚ó´ Component
                    </button>
                  </div>
                </div>

                {/* Images */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>
                    Images {(newRef.type === 'web' || newRef.type === 'mobile' || newRef.type === 'graphic') ? '(Ïó¨Îü¨ Ïû• Í∞ÄÎä•)' : '(1Ïû•)'}
                  </label>
                  <div style={styles.imageUploadArea}>
                    {newRef.images.map(img => (
                      <div key={img.id} style={styles.uploadedImage}>
                        <img src={img.src} alt="" style={styles.uploadedThumb} />
                        <button style={styles.removeImgBtn} onClick={() => handleRemoveImage(img.id)}>‚úï</button>
                        <textarea
                          placeholder="Ïù¥ÎØ∏ÏßÄ ÏÑ§Î™Ö..."
                          value={img.note}
                          onChange={e => handleImageNoteChange(img.id, e.target.value)}
                          style={styles.imgNoteInput}
                        />
                        {(newRef.type === 'web' || newRef.type === 'mobile' || newRef.type === 'graphic') && (
                          <label style={styles.componentCheckbox}>
                            <input
                              type="checkbox"
                              checked={img.isComponent || false}
                              onChange={() => handleToggleComponent(img.id)}
                            />
                            <span>ComponentÎ°ú Ï∂îÍ∞Ä</span>
                          </label>
                        )}
                      </div>
                    ))}
                    {(newRef.type === 'web' || newRef.type === 'mobile' || newRef.type === 'graphic' || newRef.images.length === 0) && (
                      <label style={styles.addImageBtn}>
                        + Add Image
                        <input
                          type="file"
                          accept="image/*"
                          multiple={newRef.type !== 'component'}
                          onChange={e => handleImageUpload(e)}
                          style={{ display: 'none' }}
                        />
                      </label>
                    )}
                  </div>
                </div>

                {/* Title */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Title *</label>
                  <input
                    type="text"
                    value={newRef.title}
                    onChange={e => setNewRef(p => ({ ...p, title: e.target.value }))}
                    style={styles.input}
                    placeholder="e.g., Linear Homepage"
                  />
                </div>

                {/* URL */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>URL</label>
                  <input
                    type="url"
                    value={newRef.url}
                    onChange={e => setNewRef(p => ({ ...p, url: e.target.value }))}
                    style={styles.input}
                    placeholder="https://example.com"
                  />
                </div>

                {/* Category */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Category</label>
                  <div style={styles.categoryInputWrapper} ref={categoryInputRef}>
                    <input
                      type="text"
                      value={newRef.category}
                      onChange={e => { setNewRef(p => ({ ...p, category: e.target.value })); setShowCategorySuggestions(true); }}
                      onFocus={() => setShowCategorySuggestions(true)}
                      onBlur={handleCategoryInputBlur}
                      onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); handleAddCategory(newRef.type, newRef.category); } }}
                      style={styles.input}
                      placeholder="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉù ÎòêÎäî ÏûÖÎ†•"
                    />
                    {showCategorySuggestions && allCategories[newRef.type]?.length > 0 && (
                      <div style={styles.categorySuggestions}>
                        {allCategories[newRef.type]
                          .filter(cat => cat.toLowerCase().includes(newRef.category.toLowerCase()))
                          .map(cat => (
                            <button 
                              key={cat} 
                              style={styles.categorySuggestion}
                              onMouseDown={e => e.preventDefault()}
                              onClick={() => { setNewRef(p => ({ ...p, category: cat })); setShowCategorySuggestions(false); }}
                            >
                              {cat}
                            </button>
                          ))}
                        {newRef.category && !allCategories[newRef.type]?.includes(newRef.category) && (
                          <button 
                            style={styles.categorySuggestionNew}
                            onMouseDown={e => e.preventDefault()}
                            onClick={() => handleAddCategory(newRef.type, newRef.category)}
                          >
                            + "{newRef.category}" Ï∂îÍ∞Ä
                          </button>
                        )}
                      </div>
                    )}
                  </div>
                </div>

                {/* Tags */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Tags</label>
                  <div style={styles.tagsContainer}>
                    {newRef.tags.map(tag => (
                      <span key={tag} style={styles.tagChip}>
                        {tag}
                        <button style={styles.tagRemove} onClick={() => handleRemoveTag(tag)}>√ó</button>
                      </span>
                    ))}
                  </div>
                  <div style={styles.tagInputWrapper} ref={tagInputRef}>
                    <input
                      type="text"
                      value={tagInput}
                      onChange={e => { setTagInput(e.target.value); setShowTagSuggestions(true); }}
                      onFocus={() => setShowTagSuggestions(true)}
                      onBlur={handleTagInputBlur}
                      onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); handleAddTag(tagInput); } }}
                      style={styles.input}
                      placeholder="ÌÉúÍ∑∏ ÏûÖÎ†• ÌõÑ Enter"
                    />
                    {showTagSuggestions && filteredTagSuggestions.length > 0 && (
                      <div style={styles.tagSuggestions}>
                        {filteredTagSuggestions.map(tag => (
                          <button key={tag} style={styles.tagSuggestion} onMouseDown={e => e.preventDefault()} onClick={() => handleAddTag(tag)}>
                            {tag}
                          </button>
                        ))}
                      </div>
                    )}
                  </div>
                </div>

                {/* Color */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Colors (Îã§Ï§ë ÏÑ†ÌÉù Í∞ÄÎä•)</label>
                  <div style={styles.colorPicker}>
                    {COLOR_OPTIONS.map(c => (
                      <button
                        key={c.id}
                        style={{
                          ...styles.colorBtn,
                          backgroundColor: c.color,
                          ...(newRef.colors?.includes(c.id) ? styles.colorBtnActive : {})
                        }}
                        onClick={() => setNewRef(p => ({ 
                          ...p, 
                          colors: p.colors?.includes(c.id) 
                            ? p.colors.filter(x => x !== c.id) 
                            : [...(p.colors || []), c.id]
                        }))}
                      />
                    ))}
                  </div>
                  <div style={styles.hexInputRow}>
                    <input
                      type="text"
                      placeholder="#FFFFFF"
                      value={newRef.hexColor || ''}
                      onChange={e => setNewRef(p => ({ ...p, hexColor: e.target.value }))}
                      style={styles.hexInput}
                      maxLength={7}
                    />
                    {newRef.hexColor && /^#[0-9A-Fa-f]{6}$/.test(newRef.hexColor) && (
                      <span style={{ ...styles.hexPreview, backgroundColor: newRef.hexColor }}></span>
                    )}
                  </div>
                </div>

                <button style={styles.submitBtn} onClick={handleAddReference}>
                  Add Reference
                </button>
              </div>
            </div>
          )}

          {/* Edit Modal */}
          {isEditModalOpen && editRef && (
            <div style={styles.modalOverlay} onClick={() => setIsEditModalOpen(false)}>
              <div style={styles.addModal} onClick={e => e.stopPropagation()}>
                <button style={styles.modalClose} onClick={() => setIsEditModalOpen(false)}>‚úï</button>
                <h2 style={styles.modalTitle}>Edit Reference</h2>

                {/* Type */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Type</label>
                  <div style={styles.typeToggle}>
                    <button
                      style={{ ...styles.typeButton, ...(editRef.type === 'web' ? styles.typeButtonActive : {}) }}
                      onClick={() => setEditRef(p => ({ ...p, type: 'web' }))}
                    >
                      ‚óé Web
                    </button>
                    <button
                      style={{ ...styles.typeButton, ...(editRef.type === 'mobile' ? styles.typeButtonActive : {}) }}
                      onClick={() => setEditRef(p => ({ ...p, type: 'mobile' }))}
                    >
                      ‚óê Mobile
                    </button>
                    <button
                      style={{ ...styles.typeButton, ...(editRef.type === 'graphic' ? styles.typeButtonActive : {}) }}
                      onClick={() => setEditRef(p => ({ ...p, type: 'graphic' }))}
                    >
                      ‚óà Graphic
                    </button>
                    <button
                      style={{ ...styles.typeButton, ...(editRef.type === 'component' ? styles.typeButtonActive : {}) }}
                      onClick={() => setEditRef(p => ({ ...p, type: 'component' }))}
                    >
                      ‚ó´ Component
                    </button>
                  </div>
                </div>

                {/* Images */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Images</label>
                  <div style={styles.imageUploadArea}>
                    {editRef.images.map(img => (
                      <div key={img.id} style={styles.uploadedImage}>
                        <img src={img.src} alt="" style={styles.uploadedThumb} />
                        <button style={styles.removeImgBtn} onClick={() => handleRemoveImage(img.id, true)}>‚úï</button>
                        <textarea
                          placeholder="Ïù¥ÎØ∏ÏßÄ ÏÑ§Î™Ö..."
                          value={img.note}
                          onChange={e => handleImageNoteChange(img.id, e.target.value, true)}
                          style={styles.imgNoteInput}
                        />
                        {editRef.type !== 'component' && (
                          <label style={styles.componentCheckbox}>
                            <input
                              type="checkbox"
                              checked={img.isComponent || false}
                              onChange={() => handleToggleComponent(img.id, true)}
                            />
                            <span>ComponentÎ°ú Ï∂îÍ∞Ä</span>
                          </label>
                        )}
                      </div>
                    ))}
                    {(editRef.type !== 'component' || editRef.images.length === 0) && (
                      <label style={styles.addImageBtn}>
                        + Add Image
                        <input
                          type="file"
                          accept="image/*"
                          multiple={editRef.type !== 'component'}
                          onChange={e => handleImageUpload(e, true)}
                          style={{ display: 'none' }}
                        />
                      </label>
                    )}
                  </div>
                </div>

                {/* Title */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Title *</label>
                  <input
                    type="text"
                    value={editRef.title}
                    onChange={e => setEditRef(p => ({ ...p, title: e.target.value }))}
                    style={styles.input}
                  />
                </div>

                {/* URL */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>URL</label>
                  <input
                    type="url"
                    value={editRef.url || ''}
                    onChange={e => setEditRef(p => ({ ...p, url: e.target.value }))}
                    style={styles.input}
                  />
                </div>

                {/* Category */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Category</label>
                  <div style={styles.categoryInputWrapper}>
                    <input
                      type="text"
                      value={editRef.category}
                      onChange={e => { setEditRef(p => ({ ...p, category: e.target.value })); setShowCategorySuggestions(true); }}
                      onFocus={() => setShowCategorySuggestions(true)}
                      style={styles.input}
                      placeholder="Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÑ†ÌÉù ÎòêÎäî ÏûÖÎ†•"
                    />
                    {showCategorySuggestions && allCategories[editRef.type]?.length > 0 && (
                      <div style={styles.categorySuggestions}>
                        {allCategories[editRef.type]
                          .filter(cat => cat.toLowerCase().includes((editRef.category || '').toLowerCase()))
                          .map(cat => (
                            <button 
                              key={cat} 
                              style={styles.categorySuggestion} 
                              onClick={() => { setEditRef(p => ({ ...p, category: cat })); setShowCategorySuggestions(false); }}
                            >
                              {cat}
                            </button>
                          ))}
                      </div>
                    )}
                  </div>
                </div>

                {/* Tags */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Tags</label>
                  <div style={styles.tagsContainer}>
                    {editRef.tags?.map(tag => (
                      <span key={tag} style={styles.tagChip}>
                        {tag}
                        <button style={styles.tagRemove} onClick={() => handleRemoveTag(tag, true)}>√ó</button>
                      </span>
                    ))}
                  </div>
                  <div style={styles.tagInputWrapper}>
                    <input
                      type="text"
                      value={tagInput}
                      onChange={e => { setTagInput(e.target.value); setShowTagSuggestions(true); }}
                      onFocus={() => setShowTagSuggestions(true)}
                      onBlur={handleTagInputBlur}
                      onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); handleAddTag(tagInput, true); } }}
                      style={styles.input}
                      placeholder="ÌÉúÍ∑∏ ÏûÖÎ†• ÌõÑ Enter"
                    />
                    {showTagSuggestions && filteredTagSuggestions.length > 0 && (
                      <div style={styles.tagSuggestions}>
                        {filteredTagSuggestions.map(tag => (
                          <button key={tag} style={styles.tagSuggestion} onMouseDown={e => e.preventDefault()} onClick={() => handleAddTag(tag, true)}>
                            {tag}
                          </button>
                        ))}
                      </div>
                    )}
                  </div>
                </div>

                {/* Color */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Colors (Îã§Ï§ë ÏÑ†ÌÉù Í∞ÄÎä•)</label>
                  <div style={styles.colorPicker}>
                    {COLOR_OPTIONS.map(c => (
                      <button
                        key={c.id}
                        style={{
                          ...styles.colorBtn,
                          backgroundColor: c.color,
                          ...(editRef.colors?.includes(c.id) ? styles.colorBtnActive : {})
                        }}
                        onClick={() => setEditRef(p => ({ 
                          ...p, 
                          colors: p.colors?.includes(c.id) 
                            ? p.colors.filter(x => x !== c.id) 
                            : [...(p.colors || []), c.id]
                        }))}
                      />
                    ))}
                  </div>
                  <div style={styles.hexInputRow}>
                    <input
                      type="text"
                      placeholder="#FFFFFF"
                      value={editRef.hexColor || ''}
                      onChange={e => setEditRef(p => ({ ...p, hexColor: e.target.value }))}
                      style={styles.hexInput}
                      maxLength={7}
                    />
                    {editRef.hexColor && /^#[0-9A-Fa-f]{6}$/.test(editRef.hexColor) && (
                      <span style={{ ...styles.hexPreview, backgroundColor: editRef.hexColor }}></span>
                    )}
                  </div>
                </div>

                <div style={styles.editBtns}>
                  <button style={styles.cancelBtn} onClick={() => setIsEditModalOpen(false)}>Cancel</button>
                  <button style={styles.submitBtn} onClick={handleSaveEdit}>Save Changes</button>
                </div>
              </div>
            </div>
          )}

          {/* Image Zoom */}
          {imageZoom && (
            <div style={styles.zoomOverlay} onClick={() => setImageZoom(null)}>
              <img src={imageZoom} alt="" style={styles.zoomImage} />
            </div>
          )}
        </div>
      );
    }

    const styles = {
      container: { minHeight: '100vh', padding: '20px' },
      header: { maxWidth: '1400px', margin: '0 auto 30px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' },
      headerInner: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%' },
      logo: { display: 'flex', alignItems: 'center', gap: '8px' },
      logoIcon: { fontSize: '28px', color: '#6366f1' },
      logoText: { fontSize: '24px', fontWeight: '700', fontFamily: '"Space Grotesk", sans-serif' },
      addButton: { padding: '10px 20px', background: 'linear-gradient(135deg, #6366f1, #8b5cf6)', color: '#fff', border: 'none', borderRadius: '10px', fontWeight: '600', cursor: 'pointer', fontFamily: '"Outfit", sans-serif' },
      filterSection: { maxWidth: '1400px', margin: '0 auto 20px', display: 'flex', gap: '16px', alignItems: 'center', flexWrap: 'wrap' },
      typeToggle: { display: 'flex', gap: '8px' },
      typeButton: { padding: '8px 16px', background: '#fff', border: '1px solid #e5e7eb', borderRadius: '8px', cursor: 'pointer', fontFamily: '"Outfit", sans-serif', fontSize: '14px' },
      typeButtonActive: { background: '#6366f1', color: '#fff', borderColor: '#6366f1' },
      searchWrapper: { position: 'relative', display: 'flex', alignItems: 'center', flex: 1, maxWidth: '400px', minWidth: '280px' },
      searchIcon: { position: 'absolute', left: '14px', fontSize: '16px', pointerEvents: 'none', opacity: 0.5 },
      searchInput: { width: '100%', padding: '12px 40px 12px 42px', border: '1px solid #e5e7eb', borderRadius: '12px', fontSize: '14px', fontFamily: '"Outfit", sans-serif', background: '#fff', boxShadow: '0 2px 4px rgba(0,0,0,0.02)' },
      searchClear: { position: 'absolute', right: '12px', background: 'none', border: 'none', fontSize: '16px', cursor: 'pointer', color: '#999', padding: '4px' },
      categoryFilter: { maxWidth: '1400px', margin: '0 auto 20px', display: 'flex', gap: '8px', flexWrap: 'wrap' },
      catButton: { padding: '6px 12px', background: '#fff', border: '1px solid #e5e7eb', borderRadius: '6px', cursor: 'pointer', fontSize: '13px', fontFamily: '"Outfit", sans-serif' },
      catButtonActive: { background: '#f0f0ff', borderColor: '#6366f1', color: '#6366f1' },
      grid: { maxWidth: '1400px', margin: '0 auto', display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))', gap: '20px' },
      card: { background: '#fff', borderRadius: '16px', overflow: 'hidden', cursor: 'pointer', boxShadow: '0 2px 8px rgba(0,0,0,0.06)', transition: 'transform 0.2s, box-shadow 0.2s' },
      cardImageWrapper: { position: 'relative', aspectRatio: '16/10', overflow: 'hidden' },
      cardImage: { width: '100%', height: '100%', objectFit: 'cover' },
      imageCount: { position: 'absolute', top: '8px', right: '8px', background: 'rgba(0,0,0,0.6)', color: '#fff', padding: '4px 8px', borderRadius: '4px', fontSize: '12px' },
      figmaBadge: { position: 'absolute', bottom: '8px', right: '8px', background: '#6366f1', color: '#fff', padding: '4px 8px', borderRadius: '4px', fontSize: '12px' },
      cardContent: { padding: '16px' },
      cardTitle: { fontSize: '16px', fontWeight: '600', marginBottom: '8px', fontFamily: '"Space Grotesk", sans-serif' },
      cardTags: { display: 'flex', gap: '6px', flexWrap: 'wrap' },
      cardTag: { fontSize: '12px', color: '#6366f1', background: '#f0f0ff', padding: '2px 8px', borderRadius: '4px' },
      modalOverlay: { position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000, padding: '20px' },
      modal: { background: '#fff', borderRadius: '20px', maxWidth: '900px', width: '100%', maxHeight: '90vh', overflow: 'auto', position: 'relative' },
      addModal: { background: '#fff', borderRadius: '20px', maxWidth: '720px', width: '100%', maxHeight: '90vh', overflow: 'auto', padding: '32px', position: 'relative' },
      modalClose: { position: 'absolute', top: '16px', right: '16px', width: '36px', height: '36px', background: '#f5f5f5', border: 'none', borderRadius: '50%', cursor: 'pointer', fontSize: '18px', zIndex: 10 },
      imageGallery: { position: 'relative' },
      modalImage: { width: '100%', maxHeight: '400px', objectFit: 'contain', background: '#f5f5f5', cursor: 'zoom-in' },
      imageThumbs: { display: 'flex', gap: '8px', padding: '12px', background: '#f9f9f9', overflowX: 'auto' },
      thumbImg: { width: '60px', height: '40px', objectFit: 'cover', borderRadius: '4px', cursor: 'pointer', opacity: 0.6, transition: 'opacity 0.2s' },
      thumbImgActive: { opacity: 1, boxShadow: '0 0 0 2px #6366f1' },
      modalContent: { padding: '24px' },
      modalMeta: { display: 'flex', gap: '8px', alignItems: 'center', color: '#888', fontSize: '14px', marginBottom: '8px' },
      modalType: { color: '#6366f1', fontWeight: '600' },
      modalTitle: { fontSize: '24px', fontWeight: '700', marginBottom: '12px', fontFamily: '"Space Grotesk", sans-serif' },
      modalUrl: { display: 'inline-block', color: '#6366f1', fontSize: '14px', marginBottom: '12px', textDecoration: 'none' },
      modalNote: { color: '#555', fontSize: '15px', lineHeight: 1.6, marginBottom: '16px', padding: '16px', background: '#f9f9f9', borderRadius: '8px', minHeight: '60px' },
      modalTags: { display: 'flex', gap: '8px', flexWrap: 'wrap', marginBottom: '20px' },
      modalTag: { fontSize: '13px', color: '#6366f1', background: '#f0f0ff', padding: '4px 12px', borderRadius: '6px' },
      figmaSection: { marginBottom: '20px' },
      figmaHeader: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' },
      copyBtn: { padding: '8px 16px', background: '#6366f1', color: '#fff', border: 'none', borderRadius: '6px', cursor: 'pointer', fontSize: '13px', fontWeight: '500', transition: 'all 0.2s' },
      copyBtnSuccess: { background: '#22c55e' },
      figmaCode: { background: '#1e1e2e', color: '#a5d6ff', padding: '16px', borderRadius: '8px', fontSize: '12px', fontFamily: 'monospace', overflow: 'auto', maxHeight: '300px', whiteSpace: 'pre-wrap', wordBreak: 'break-all' },
      figmaHint: { marginTop: '8px', fontSize: '12px', color: '#888', fontStyle: 'italic' },
      generateBtn: { width: '100%', padding: '14px', background: 'linear-gradient(135deg, #6366f1, #8b5cf6)', color: '#fff', border: 'none', borderRadius: '10px', fontWeight: '600', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', fontFamily: '"Outfit", sans-serif' },
      generateBtnDisabled: { background: '#a5a6f6', cursor: 'not-allowed' },
      spinner: { width: '16px', height: '16px', border: '2px solid rgba(255,255,255,0.3)', borderTopColor: '#fff', borderRadius: '50%', animation: 'spin 0.8s linear infinite' },
      modalFooter: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', paddingTop: '16px', borderTop: '1px solid #eee' },
      modalActions: { display: 'flex', gap: '8px' },
      editBtn: { padding: '8px 16px', background: '#f0f0f5', border: 'none', borderRadius: '8px', cursor: 'pointer', fontFamily: '"Outfit", sans-serif' },
      deleteBtn: { padding: '8px 16px', background: '#fee2e2', color: '#dc2626', border: 'none', borderRadius: '8px', cursor: 'pointer', fontFamily: '"Outfit", sans-serif' },
      formGroup: { marginBottom: '20px' },
      label: { display: 'block', fontSize: '14px', fontWeight: '600', marginBottom: '8px', color: '#333' },
      input: { width: '100%', padding: '12px', border: '1px solid #e5e7eb', borderRadius: '8px', fontSize: '14px', fontFamily: '"Outfit", sans-serif' },
      select: { width: '100%', padding: '12px', border: '1px solid #e5e7eb', borderRadius: '8px', fontSize: '14px', fontFamily: '"Outfit", sans-serif' },
      imageUploadArea: { display: 'flex', flexWrap: 'wrap', gap: '16px' },
      uploadedImage: { position: 'relative', width: '180px' },
      uploadedThumb: { width: '180px', height: '120px', objectFit: 'cover', borderRadius: '8px' },
      removeImgBtn: { position: 'absolute', top: '-8px', right: '-8px', width: '24px', height: '24px', background: '#ef4444', color: '#fff', border: 'none', borderRadius: '50%', cursor: 'pointer', fontSize: '14px', fontWeight: 'bold' },
      imgNoteInput: { width: '100%', marginTop: '8px', padding: '10px', border: '1px solid #e5e7eb', borderRadius: '6px', fontSize: '13px', fontFamily: '"Outfit", sans-serif', resize: 'vertical', minHeight: '60px' },
      addImageBtn: { width: '180px', height: '120px', border: '2px dashed #d1d5db', borderRadius: '8px', display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', color: '#9ca3af', fontSize: '14px', fontFamily: '"Outfit", sans-serif', transition: 'border-color 0.2s' },
      tagsContainer: { display: 'flex', flexWrap: 'wrap', gap: '8px', marginBottom: '8px' },
      tagChip: { display: 'flex', alignItems: 'center', gap: '4px', background: '#f0f0ff', color: '#6366f1', padding: '4px 10px', borderRadius: '6px', fontSize: '13px' },
      tagRemove: { background: 'none', border: 'none', color: '#6366f1', cursor: 'pointer', fontSize: '16px', padding: 0 },
      tagInputWrapper: { position: 'relative' },
      tagSuggestions: { position: 'absolute', bottom: '100%', left: 0, right: 0, background: '#fff', border: '1px solid #e5e7eb', borderRadius: '8px', boxShadow: '0 -4px 12px rgba(0,0,0,0.1)', zIndex: 10, maxHeight: '200px', overflow: 'auto', marginBottom: '4px' },
      tagSuggestion: { display: 'block', width: '100%', padding: '10px 12px', border: 'none', background: 'none', textAlign: 'left', cursor: 'pointer', fontSize: '13px', fontFamily: '"Outfit", sans-serif' },
      categoryInputWrapper: { position: 'relative' },
      categorySuggestions: { position: 'absolute', bottom: '100%', left: 0, right: 0, background: '#fff', border: '1px solid #e5e7eb', borderRadius: '8px', boxShadow: '0 -4px 12px rgba(0,0,0,0.1)', zIndex: 10, maxHeight: '200px', overflow: 'auto', marginBottom: '4px' },
      categorySuggestion: { display: 'block', width: '100%', padding: '10px 12px', border: 'none', background: 'none', textAlign: 'left', cursor: 'pointer', fontSize: '13px', fontFamily: '"Outfit", sans-serif' },
      categorySuggestionNew: { display: 'block', width: '100%', padding: '10px 12px', border: 'none', background: '#f0fdf4', color: '#16a34a', textAlign: 'left', cursor: 'pointer', fontSize: '13px', fontFamily: '"Outfit", sans-serif', fontWeight: '500' },
      colorPicker: { display: 'flex', gap: '8px', flexWrap: 'wrap', marginBottom: '12px' },
      colorBtn: { width: '32px', height: '32px', borderRadius: '50%', border: '2px solid transparent', cursor: 'pointer', transition: 'transform 0.2s, box-shadow 0.2s' },
      colorBtnActive: { transform: 'scale(1.15)', boxShadow: '0 0 0 3px rgba(99,102,241,0.4)' },
      hexInputRow: { display: 'flex', gap: '8px', alignItems: 'center' },
      hexInput: { width: '120px', padding: '8px 12px', border: '1px solid #e5e7eb', borderRadius: '6px', fontSize: '13px', fontFamily: 'monospace' },
      hexPreview: { width: '32px', height: '32px', borderRadius: '6px', border: '1px solid #e5e7eb' },
      componentCheckbox: { display: 'flex', alignItems: 'center', gap: '6px', marginTop: '6px', fontSize: '12px', color: '#6366f1', cursor: 'pointer' },
      submitBtn: { width: '100%', padding: '14px', background: 'linear-gradient(135deg, #6366f1, #8b5cf6)', color: '#fff', border: 'none', borderRadius: '10px', fontWeight: '600', cursor: 'pointer', fontSize: '15px', fontFamily: '"Outfit", sans-serif' },
      editBtns: { display: 'flex', gap: '12px' },
      cancelBtn: { flex: 1, padding: '14px', background: '#f0f0f5', border: 'none', borderRadius: '10px', cursor: 'pointer', fontFamily: '"Outfit", sans-serif' },
      categoryFilterSection: { maxWidth: '1400px', margin: '0 auto 16px', display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap', padding: '12px 16px', background: '#fff', borderRadius: '12px', boxShadow: '0 1px 3px rgba(0,0,0,0.05)' },
      filterLabel: { fontSize: '13px', color: '#888', fontWeight: '600', minWidth: '70px' },
      categoryFilter: { display: 'flex', gap: '8px', flexWrap: 'wrap' },
      catButton: { padding: '6px 14px', background: '#f5f5f5', border: 'none', borderRadius: '6px', cursor: 'pointer', fontSize: '13px', fontFamily: '"Outfit", sans-serif', color: '#555', transition: 'all 0.2s' },
      catButtonActive: { background: '#6366f1', color: '#fff' },
      tagFilterSection: { maxWidth: '1400px', margin: '0 auto 20px', display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap', padding: '12px 16px', background: '#fff', borderRadius: '12px', boxShadow: '0 1px 3px rgba(0,0,0,0.05)' },
      tagFilterList: { display: 'flex', gap: '8px', flexWrap: 'wrap', alignItems: 'center' },
      tagFilterBtn: { padding: '4px 12px', background: '#f0f0ff', border: 'none', borderRadius: '6px', cursor: 'pointer', fontSize: '12px', fontFamily: '"Outfit", sans-serif', color: '#6366f1', transition: 'all 0.2s' },
      tagFilterBtnActive: { background: '#6366f1', color: '#fff' },
      clearTagsBtn: { padding: '4px 12px', background: '#fef2f2', color: '#dc2626', border: 'none', borderRadius: '6px', cursor: 'pointer', fontSize: '12px', fontFamily: '"Outfit", sans-serif' },
      zoomOverlay: { position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.95)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000, cursor: 'zoom-out' },
      zoomImage: { maxWidth: '95vw', maxHeight: '95vh', objectFit: 'contain' },
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
